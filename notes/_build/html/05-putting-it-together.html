
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Integrating Formal Specification with Imperative Programming &#8212; Mathematical Logic in Software Development 1 documentation</title>
    <link rel="stylesheet" href="_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/sidebar.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Pure Functional Programming as Runnable Mathematics" href="04-runnable-math.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="04-runnable-math.html" title="Pure Functional Programming as Runnable Mathematics"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Mathematical Logic in Software Development 1 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="integrating-formal-specification-with-imperative-programming">
<h1>Integrating Formal Specification with Imperative Programming<a class="headerlink" href="#integrating-formal-specification-with-imperative-programming" title="Permalink to this headline">¶</a></h1>
<p>To get a clear sense of the potential differences in performance
between a pure functional program and an imperative program that
compute the same function, consider our recursive definition of the
factorial function.</p>
<p>We start with the statement that if <em>n</em> is <em>0</em> or <em>1</em> the answer is
<em>n</em>.  In other words, the <em>sequence</em>, <em>fib(i)</em> of <em>Fibonacci numbers
indexed by i</em>, starts with, <span class="math">\([0, 1, \ldots ]\)</span>. Here we have the
values of <em>fib(0)</em>, the first Fibonacci number and <em>fib(1)</em>, the
second. The third, <em>fib(2)</em> would be the sum of the first two.</p>
<p>You will note that we (generally) start indexing sequences at zero
rather than one. The first element in such a sequence has index <em>0</em>,
the second has index <em>1</em>, etc.</p>
<p>For any <em>i &gt;= 1</em>, the next element after <em>i</em>, <em>fib(i+1)</em> (let’s call
it <em>fib2</em>) is the sum of the previous two elements, banely <em>fib(i-1)</em>
and fib(i)* (let’s call them <em>fib0</em> and <em>fib1</em>, respectively).</p>
<p>Our recursive definition, <em>fib(n)</em> is pure math: elegant and precise.
And because we’ve written in a functional programming language, we can
even run it if we wish. An imperative program, by constrast, will just
repeated add the last two two known Fibonacci numbers together to get
the next one until the desired <em>nth</em> one is computed.</p>
<p>Now let’s consider the evaluation of each program given the value, <em>n
= 7</em>. Start with the imperative program. The answers for the first two
values are zero and one. If <em>n</em> is either zero or one the answer is
just returned; otherwise it is computed and returned. In this case,
the program will repeatedly add together the last two known values of
the function (starting with the <em>0</em> and <em>1</em>) to obtain the next one.
It will then store (remember) the previous and current values of the
function to get ready for the next iteration of the loop, terminating
once the <em>n’th</em> value in the sequence of Fibonacci numbers has been
computed. The program returns that value.</p>
<p>Question: How many executions of the loop body are required to compute
<em>fib(5)</em>? Well, we need to execute it for values of <em>i</em> of <em>2, 3, 4,</em>
and <em>5</em>. It takes <em>4</em> <a href="#id1"><span class="problematic" id="id2">**</span></a>n-1* iterations. To compute the 10th element
requires that the loop body execute for <em>i</em> in the range (inclusive
of <em>[2, 3, …, 10]</em>, which means nine iterations of the loop will be
required, or, again, <em>n-1</em>. Indeed, it’s pretty easy to see that for
any value of <em>n</em>, <em>n-1</em> iterations of the loop body will be required
to compute the <em>nth</em> Fibonacci number.</p>
<p>The functional program, on the other hand, is evaluated by repeated
unfolding of nested recursive definitions until values are computed,
at which point the values are combined into a final result. Let’s see
if we can see a pattern. We’ll measure computational complexity now in
terms of the number of function evaluations (rather than loop bodies
executed).</p>
<p>To compute $fib(0)* or $fib(1)$ requires just $1$ function evaluation,
as these are base cases with no recursive calls to solve subproblems.
To compute <em>fib(2)</em> however requires <em>3</em> evalations of <em>fib</em>, one for
<em>2</em> and one for each of <em>1</em> and <em>0</em>. Those count as just one each as
there are no further recursive calls. So the relationship between <em>n</em>
and the number of function evaluations currently looks like this:
<span class="math">\(\{ (0,1), (1,1), (2,3), ... \}.\)</span></p>
<p>What about when <em>n</em> is <em>3</em>?  Computing this requires answers for
<em>fib(2)</em>, costing <em>3</em> evaluations, and <em>fib(1)</em>, costing one, for a
total of <em>5</em> evaluations. Computing <em>fib(4)</em> requires answers for
<em>fib(3)</em> and <em>fib(2)</em>, costing <em>5 + 3</em>, or <em>8</em> evaluations, plus the
original evaluation is 9. For <em>fib(5)</em> we need <em>9</em> + <em>5</em>, or <em>14</em>,
plus the original makes $15* evaluations.  relation is like this:
<span class="math">\(\{ (0,1), (1,1), (2,3), (3,5), (4,9), (5, 15), ... \}.\)</span> So, in
general, the number of evaluations needed to evaluate <em>fib(i+1)</em> is
the sum of the numbers required to compute <em>fib(i)</em> and <em>fib(i-1) +
1.</em> Now that we see the formula, we can compute the next entry in the
sequence easily: the number of function evaluations needed to compute
<em>fib(6)</em> is <em>15 + 9 + 1</em>, i.e., 25. Computing the value of <em>fib(7)</em>
costs <em>41</em> evaluations; <em>fib(8), *67*l *fib(9), 109</em>, <em>fib(10), 177</em>
and <em>fib(11), 286</em> function evaluations.</p>
<p>With out imperative program, the number of loop body interations grows
linearly with <em>n</em>. We could say that the computational cost of running
the imperative program to compute <em>fib(n)</em>, let’s call it <em>cost(n) is
just *n+1</em>. How does the cost of the (doubly) recursive program grow
as a function of <em>n</em>? Well, one thing to notice is that the cost of
computing the Fibonacci sequence is close to the Fibonacci sequence
itself! The first two values in the <em>cost</em> sequence are <em>1</em> and <em>1</em>,
and each subsequence element is the sum of the previous two <em>plus 1</em>.
It’s not exactly the Fibonacci sequence, but it turns out to grow at
the same rate overall. Without getting into details, the Fibonacci
sequence, and thus also the cost of computing it recursively, grows at
an exponential rate, with an exponent of about <em>1.6</em>. Increasing <em>n</em>
by <em>1</em> does quite double the previous cost, but it does multiply it by
about <em>1.6</em>.</p>
<p>No matter how small the exponent, exponential functions eventually
grow very large very quickly. You can already see that the cost to
compute <em>fib(n)</em> recursively for values of <em>n</em> larger than just ten or
so is vastly greater than the cost to compute it iteratively. The math
(the recursive definition clear but inefficient. The program is
efficient, but woefully not transparent as to its function. We need
the latter program for practical computation. But how do we ensure
that hard to understand imperative code flawlessly implements the same
function that we expressed so elegantly in mathematical logic and its
computational expression in pure functional programming?</p>
<p>We address such problems by combining a few ideas. First, we use logic
to express <em>declarative</em> specifications that precisely define <em>what</em> a
given imperative program must do, an in particular what results it
must return as a function of the arguements it received.</p>
<p>We can use functions defined in the pure functional programming style
as specifications, e.g., as giving the mathematical definition of the
<em>factorial</em> function that an imperative program is meant to implement.</p>
<p>Second, we implement the specified program in an imperative language
in a way that supports logical reasoning about its behavior. What kind
of support is needed to facilitate logical reasoning is broached in
this chapter. For example, we have to specify not only the desired
relationship between argument and result values, but also how loops
are designed to work in our code; and we need to design loops in ways
that make it easier to explain in formal logic how they do what they
are meant to do.</p>
<p>Finally, we use logical proofs to <em>verify</em> that the program satisifies
its specification.</p>
<p>We develop these idea in this chapter. First we explain how formal
specifications in mathematical logic for imperative programs are often
organized. Next we explore how writing imperative programs without the
benefits of specification languages and verifications tools can make
it hard to spot bugs in code. Next we enhance our implementation of
the factorial function with specifications, show how Dafny flags the
bug, and fix out program. Doing this requires that we deepen the way
we understand loops. We end with a detailed presentation of the design
and verification of an imperative program to compute elements in the
Fibonacci sequence. Given any natural number <em>n</em>, our program must
return the value of <em>fib(n)</em>, but it must also do it efficiently.  The
careful design of a loop is once again the very heart of the problem.
We will see how Dafny can help us to reason rigorously about loops,
and that, with just a bit of help, it can reason about them for us.</p>
<div class="section" id="logical-specification">
<h2>Logical Specification<a class="headerlink" href="#logical-specification" title="Permalink to this headline">¶</a></h2>
<p>First, we use mathematical logic to <em>declaratively specify</em> properties
of the behaviors that we require of programs written in <em>imperative</em>
languages. For example, we might require that, when given any natural
number, $n$, a program compute and return the value of the $factorial$
of $n$, the mathematical definition of which we’ve given as $fact(n)$.</p>
<p>Specifications about required relationships between argument values
and return results are especially important. They specify <em>what</em> a
program must compute without specifying how. Specifications are thus
<em>abstract</em>: they omit <em>implementation details</em>, leaving it to the
programmer to decide how best to <em>refine</em> the specification into a
working program.</p>
<p>For example we might specify that a program (1) must accept any
integer valued argument greater than or equal to zero (a piece of a
specification that we call a <em>precondition</em>), and (2) that as long as
the precondition holds, then it must return the factorial of the given
argument value (a <em>postcondition</em>).</p>
<p>In purely mathematical terms, a specification of this kind defines a
<em>binary relation</em> between argument and return values, and imposes on
the program a requirement that whenever it is given the first value in
such a pair, it must compute a second value so that the <span class="math">\((first
value, second value)\)</span> pair is in the specified relation.</p>
<p>A binary relation in ordinary mathematics is just a set of pairs of
values. A function is a special binary relation with at most one pair
with a given first value. A function is said to be a <em>single-valued</em>
relation.</p>
<p>For example, pairs of non-negative integers in the relation that
constitutes the factorial function include <span class="math">\((0,1), (1,1), (2,2),
(3,6), (4,24)\)</span> and <span class="math">\((5,120)\)</span>, but not <span class="math">\((5,25)\)</span>.</p>
<p>On the other hand, square root is a relation but not a <em>function</em>. It
is not singled valued. Both <span class="math">\((4,2)\)</span> and <span class="math">\((4,-2)\)</span>, two
pairs with the same first element but different second elements, are
in the relation. That is because both <em>2</em> and <em>-2</em> are squarer roots
of <em>4</em>.  The <em>positive square root</em> relation, on the other hand, is a
function, comprising those pairs in the square root relation where
both elements are non-negative. It thus includes <span class="math">\((4,2)\)</span> but
not  <span class="math">\((4,-2)\)</span>.</p>
<p>We could formulate the square root <em>relation</em> as a <em>function</em> in a
different way: by viewing it as a relation that associates with each
non-negative integer the single <em>set</em> of its square roots. The pair
<span class="math">\((4, \{2, -2\}\)</span> is in this relation, for example. The relation is
now also a function in that there is only one such pair with a given
first element.</p>
<p>Now what we mean when we say that a program computes a function or a
relation is that whenever it is given a valid argument representing
the <em>first</em> value of a pair in the relation, it computes a <em>second</em>
value such that the pair, <span class="math">\((first, second)\)</span> is in the given
relation. When we say, for example, that a program <em>computes the
factorial function</em>, we mean that if we give it a non-negative number,
<em>n</em>, it returns a number <em>m</em> such that the pair <em>(n,m)</em> is <em>in</em> the
relation. And for <em>(n,m)</em> to be in the relation it must be that
<span class="math">\(m = fact(n)\)</span>. The program thus has to return <span class="math">\(fact(n)\)</span>.</p>
<p>A program that computes a <em>function</em> is deterministic, in the sense
that it can return at most one result: because there is at most one
result. When a program computes a relation that is not a function, it
can return any value, <em>m</em>, where <em>(n,m)</em> is in the specified relation.</p>
</div>
<div class="section" id="rigorous-implementation">
<h2>Rigorous Implementation<a class="headerlink" href="#rigorous-implementation" title="Permalink to this headline">¶</a></h2>
<p>Having written a formal specification of the required <em>input-output</em>
behavior of a program, we next write imperative code in a manner, and
in a language, that supports the use of formal logic to <em>reason</em> about
whether the program refines (implements) its formal specification. One
can use formal specifications when programming in any language, but it
helps greatly if the language has strong, static type checking. It is
even better if the language supports formal specification and logical
reasoning mechanisms right alongside of its imperative and functional
programming capabilities. Dafny is such a language.</p>
<p>In addition to choosing a language with features that help to support
formal reasoning (such as strong, static typing), we sometimes also
aim to write imperative code in a way that makes it easier to reason
about formally (using mathematical logic). As we will see below, for
example, the way that we write our while loops can make it easier or
harder to reason about their correctness.</p>
</div>
<div class="section" id="formal-verification">
<h2>Formal Verification<a class="headerlink" href="#formal-verification" title="Permalink to this headline">¶</a></h2>
<p>Our ultimate aim to deduce that, as written, a program satisfies its
input-output specification.  In more detail, if we’re given a program,
<em>C</em> with a precondition, <em>P</em>, and a postcondition <em>Q</em>, we want a proof
that verifies that if <em>C</em> is started in a state that satisfies <em>P</em> and
if it terminates (doesn’t go into an infinite loop), that it ends in a
state that satisfies <em>Q</em>. We call this property <em>partial correctness</em>.</p>
<p>We write the proposition that <em>C</em> is partially correct in this sense
(that if it’s started in a state that satisfies the assertion, <em>P</em>,
and if it terminates then, it will do so in a state that satisfies
<em>Q</em>) as <span class="math">\(P {C} Q.\)</span> This is a so-called <em>Hoare triple</em> (named
after the famous computer scientist, Sir Anthony (Tony) Hoare. It is
nothing other than a proposition that claims that <em>C</em> satisfies its
specification.</p>
<p>In addition to a proof of partial correctness, we usually do want to
know that a program also does always terminate. When we have a proof
of both <span class="math">\(P \{C\} Q\)</span> and that the program always terminates, then
we have a proof of <em>total correctness</em>. Dafny is a programming system
that allows us to specify <em>P</em> amd <em>Q</em> and that then formally, and to a
considerable extent automatically, verifies <cite>P {C} Q</cite> and termination.
That is, Dafny produces proofs of total correctness.</p>
<p>It is important to bear in mind that a proof that a program refines
its formal specification does not necessarily mean that it is fit for
its intended purpose! If the specification is wrong, then all bets are
off, even if the program is correct relative to its specification.
The problem of <em>validating</em> specification againts real-world needs is
separate from that of <em>verifying</em> that a given program implements its
specification correctly.</p>
</div>
<div class="section" id="case-study-implementing-the-factorial-function">
<h2>Case Study: Implementing the Factorial Function<a class="headerlink" href="#case-study-implementing-the-factorial-function" title="Permalink to this headline">¶</a></h2>
<p>So far the material in this chapter has been pretty abstract. Now
we’ll see what it means in practice. To start, let’s consider an
ordinary imperative program, as you might have written in Python or
Java, for computing the factorial function. The name of the function
is the only indication of the intended behavior of this program. There
is no documented specification. The program takes an argument of type
nat (which guarantees that the argument has the property of being
non-negative). It then returns a nat which the programmer implicitly
claims (given the function name) is the factorial of the argument.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>method factorial(n: nat) returns (f: nat)
{
    if (n == 0)
    {
        return 1;
    }
    var t: nat := n;
    var a: nat := 1;
    while (t !=  0)
    {
        a := a * n;
        t := t - 1;
    }
    f := a;
}
</pre></div>
</div>
<p>Sadly, this program contains a bug. Try to find it. Reason about the
behavior of the program when the argument is 0, 1, 2, 3, etc.  Does it
always compute the right result? Where is the bug? What is wrong? And
how could this logical error have been detected automatically?</p>
<p>The problem is that the program lacks a complete specification. The
program does <em>something</em>, taking a nat and possibly returning a nat
(unless it goes into an infinite loop) but there’s no way to analyze
its correctness in the absence of a specification that defines what
<em>right</em> even means.</p>
<p>Now let’s see what happens when we make the specification complete.
The precondition will continue to be expressed by the type of the
argument, <em>n</em>, being <em>nat</em>. However, we have added a postcondition
that requires the return result to be the factorial of <em>n</em>. Note that
we used our functional definition of the <em>factorial</em> function in the
<em>specification</em> of our imperative code. The pure functional program is
really just a mathematical definition of factorial. What we assert
with the postcondition is thus that the imperative program computes
the factorial function as it is defined in pure mathematics.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>method factorial(n: nat) returns (f: nat)
    ensures f == fact(n)
{
    if (n == 0)
    {
        return 1;
    }
    var t := n;
    var a := 1;
    while (t !=  0)
    {
        a := a * n;
        t := t - 1;
    }
    return a;
}
</pre></div>
</div>
<p>Dafny now reports that it cannot guarantee—formally prove to
itself—that the <em>postcondition</em> is guaranteed to hold. Generating
proofs is hard, not only for people but also for machines. In fact,
one of seminal results of 20th century mathematical logic was to prove
that there is no general-purpose algorithm for proving propositions in
mathematical logic. That’s good news for mathematicians!  If this
weren’t true, we wouldn’t need them!</p>
<p>So, the best that a machine can do is to try to find a proof for any
given proposition. Sometimes proofs are easy to generate. For example,
it’s easy to prove <em>1 = 1</em> by the <em>reflexive</em> propery of equality.
Other propositions can be hard to prove. Proving that programs in
imperative languages satisfy declarative specifications can be hard.</p>
<p>When Dafny fails to verify a program (find a proof that it satisfies
its specification), there is one of two reasons. Either the program
really does fail to satisfy its specificaiton; or the program is good
but Dafny does not have enough information to know how to prove it.</p>
<p>With the preceding program, the postcondition really isn’t satisfied
due to the bug in the program. But even if the program were correct,
Dafny would need a little more information than is given in this code
to prove it. In particular, Dafny would need a litte more information
about how the while loop behaves. It turns out that providing extra
information about while loops is where much of the difficulty lies.</p>
</div>
<div class="section" id="a-formally-verified-implementation-of-the-factorial-function">
<h2>A Formally Verified Implementation of the Factorial Function<a class="headerlink" href="#a-formally-verified-implementation-of-the-factorial-function" title="Permalink to this headline">¶</a></h2>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>
</pre></div>
</div>
<p>Here’s verified imperative program for computing factorial. We start
by documenting the overall program specification.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>method verified_factorial(n: nat) returns (f: nat)
    ensures f == fact(n)
</pre></div>
</div>
<p>Now for the body of the method. First, if we’re looking at the case
where <em>n==0</em> we just return the right answer immediately. There is
no need for any further computation.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>if (n == 0)
{
    return 1;
}
</pre></div>
</div>
<p>The rest of the code handles the case where <em>n &gt; 1</em>. At this point in
the program execution, we believe that <em>n</em> must be greater than zero,
as we would have just returned if it were zero, and it can’t be
negative because its type is <em>nat</em>. We can nevertheless formally
assert (write a proposition about the state of the program) that <em>n</em>
is greater than zero. Dafny will try to (and here will successfully)
verify that the assertion is always true at this point in the program.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>assert n &gt; 0;
</pre></div>
</div>
<p>Strategy: use a while loop to compute the answer. We can do this by
using a variable, a, to hold a “partial factorial value” in the form
of a product of the numbers from n down to a loop index, “i,” that we
start at n and decrement down, terminating the loop when <em>n==0</em>. At
each point just before, during, and right after the loop, <em>a</em> is a
product of the numbers from <em>n</em> down to <em>i</em>, and the value of <em>i</em>
represents how much of this product-computing work remains to be
done. So, for example, if we’re computing factorial(10) and a holds
the value <em>10 * 9</em>, then <em>i</em> must be <em>8</em> because the task of
multiplying <em>a</em> by the factors from <em>8</em> down to <em>1</em> remains to be
done. A critical “invariant” then is that if you multiply <em>a</em> by the
factorial of <em>i</em> you get the final answer, the factorial of <em>n</em>.
And in particular, when <em>i</em> gets down to <em>0</em>, <em>a</em> must contain the
final result, because <em>a * fact(0)</em> will then equal <em>fact(n)</em> and
<em>fact(0)</em> is just <em>1</em>, so <em>a</em> must equal <em>fact(n)</em>. This is how we
design loops so that we can be confident that they do what we want
tem to do.</p>
<p>Step 1. Set up state for the loop to work. We first initializie a := 1
and i := n and check that the invariant holds. Note that we are using
our pure functional math-like definition of fact as a <em>specification</em>
of the factorial function we’re implementing.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>var i: nat := n;    // nat type of i explicit
var a := 1;         // can let Dafny infer it
</pre></div>
</div>
<p>In Dafny, we can use matnematical logic to express what must be true
at any given point in the execution of a program in the form of an
“assertion.” Here we assert that our loop invariant holds. The Dafny
verifier tries to prove that the assertion is a true propsition about
the state of the program when control reaches this point in the
execution of this program.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>assert a * fact(i) == fact(n); // &quot;invariant&quot;
</pre></div>
</div>
<p>Step 2: Now evaluate the loop to get the answer. To evaluate a loop,
first, evaluate the loop condition (i &gt; 0).Then , if the result is
false, terminate the loop. Otherwise, evaluate the loop body, then
iterate (run the loop again, starting by evaluating the loop
condition).</p>
<p>Note that we can deduce that the loop body is going to execute at
least once. It will run if i &gt; 0. What is i? We initialized it to n
and haven’t change it since then so it must still be equal to n. Do we
know that n is greater than 0? We do, because (1) it can’t be negative
owning to its type, and (2) it can’t be 0 because if it were 0 the
program would already have returned. But we can now do better than
just reasoning in our heads; we can use logic to express what we
believe to be true and let Dafny try to check it for us automatically.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>assert i &gt; 0;
</pre></div>
</div>
<p>Let’s just think briefly about cases. We know i can’t be zero. It
could be one. If it’s one, then the loop body will run. The loop body
will run. a, which starts at 1, will be multiplied by i, which is 1,
then i will be decremented.  It will have the value 0 and the loop
will not run again, leaving a with the value 1, which is the right
answer. So, okay, let’s run the loop.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>while (i &gt;  0)
    invariant 0 &lt;= i &lt;= n
    invariant fact(n) == a * fact(i)
{
    a := a * i;
    i := i - 1;
}
</pre></div>
</div>
<p>At this point, we know that the loop condition is false. In English,
we’d say it is no longer true that i is greater than zero.” We can do
better that saying this in natural language then forgetting it. We can
use formal logic to formalize and document our belief and if we do
this then Dafny pays us well for our effort by checking that our
assertion is true.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>assert !(i &gt; 0);
</pre></div>
</div>
<p>We can also have Dafny check that our loop invariant still holds.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>assert a * fact(i) == fact(n);
</pre></div>
</div>
<p>And now comes the most crucial step of all in our reasoning. We can
deduce that a now holds the correct answer. That this is so follows
from the conjunction of the two assertions we just made. First, that i
is not greater than 0 and given that its type is nat, the only
possible value it can have now is 0. And that’s what we’d expect,
because that’s the condition on which the loop terminates, which is
just did! But better than just saying it, let us also formalize,
document, and check it.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>assert i == 0;
</pre></div>
</div>
<p>Now it’s easy to see. No matter what value i has, a * fact(i) ==
fact(n), and i == 0, so we have a * fact(0) == fact(n), and we know
that fact(0) is 1 because we see that in the very mathematical
definition of fact, so it must be that a = fact(n). Dafny can check!</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>assert a == fact(n);
</pre></div>
</div>
<p>We thus have the answer we need to return.  Dafny verifies that our
program satisfies its formal specification. We no longer have to
pray. We <em>know</em> that our program is right and Dafny confirms our
belief.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>return a;
</pre></div>
</div>
<p>Mathematical logic is to software as the calculus is to physics and
engineering.  It’s not just an academic curiosity. It is a critical
intellectual tool, inceasingly used for precise specification and
semi-automated reasoning about and verification of real programs.</p>
</div>
<div class="section" id="case-study-verified-implementation-of-the-fibonacci-function">
<h2>Case Study: Verified Implementation of the Fibonacci Function<a class="headerlink" href="#case-study-verified-implementation-of-the-fibonacci-function" title="Permalink to this headline">¶</a></h2>
<p>Similarly, here an imperative implementation of the fibonacci
function, without a spec.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>method fibonacci(n: nat) returns (r: nat)
    ensures r == fib(n)
</pre></div>
</div>
<p>Now for the body. First we represent values for the two
cases where the result requires no further computation.
Initially, <em>fib0</em> will store the value of <em>fib(0)</em> and
<em>fib1</em> will store the value of <em>fib(1)</em>.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>var fib0, fib1 := 0, 1; //parallel assmt
</pre></div>
</div>
<p>Next, we test to see if either of these cases applies,
and if so we just return the appropriate result.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>if (n == 0) { return fib0; }
if (n == 1) { return fib1; }
</pre></div>
</div>
<p>At this point, we know something more about the state of the program
than was the case when we started. We can deduce, which is to say that
we know, that <em>n</em> has to be greater than or equal to <em>2</em>. This is
because it initially had to be greater than or equal to zero due to
its type, and then we would already have returned if it were <em>0</em> or
<em>1</em>, to it must now be <em>2</em> or greater. We can document the belief
that the current state of the program has to property that the value
of the variable <em>n</em> is greater than or equal to <em>2</em>, and Dafny will
verify this assertion for us.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>assert n &gt;= 2;
</pre></div>
</div>
<p>So now we have to deal with the case where <em>n &gt;= 2</em>. Our strategy for
computing fib(n) in this case is to use a while loop with an index i.
Our design will be based on the idea that at the beginning and end of
each loop iteration (we are currently at the beginning), we will have
computed fib(i) and that its value is stored in fib1. We’ve already
assigned the value of fib(0) to fib0, and of fib(1) to fib1, so to set
up the desired state of affairs, we should initialize <em>i</em> to be <em>1</em>.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>var i := 1;
</pre></div>
</div>
<p>We can state and Dafny can verify a number of conditions that we
expect and require to hold at this point. First, <em>fib1</em> equals
<em>fib(i)</em>. Now to compute the next (<em>i+1</em>) Fibonacci number, we need
not only the value of $fib(i)* but also <em>fib(i-1)</em>. We will thus also
want <em>fib0</em> to hold this value at the start and end of each loop
iteration, and indeed we do have that state of affairs right now.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>assert fib1 == fib(i);
assert fib0 == fib(i-1);
</pre></div>
</div>
<p>To compute <em>fib(n)</em> for any <em>n</em> greater than or equal to <em>2</em> will
require at least one execution of the loop body. We’ll thus set our
loop condition to be $i &lt; n$. This ensures that the loop body will
run, as <em>i</em> is <em>1</em> and <em>n</em> is at least <em>2</em>, so the condition <em>i &lt; n</em>
is <em>true</em>, which dictates that the loop body must be evaluated.</p>
<p>Within the loop body we’ll compute fib(i+1) (we call it <em>fib2</em> within
the loop) by adding together <em>fib0</em> and <em>fib1</em>; then we increment i;
then we update <em>fib0</em> and <em>fib1</em> so that for the <em>new</em> value of <em>i</em>
they hold <em>fib(i-1)</em> and <em>fib(i)</em>. To do this we assign the initial
value of <em>fib1</em> to <em>fib0</em> and the value of <em>fib2</em> to <em>fib1</em>.</p>
<p>Let’s work an example. Suppose <em>n</em> happens to be <em>2</em>. The loop body
will run, and after the one execution, <em>i</em> will have the value, <em>2</em>;
<em>fib1</em> will have the value of $fib(2)$, and <em>fib0</em> will have the value
of <em>fib(1)$. Because *i</em> is now <em>2</em> and <em>n</em> is still <em>2</em>, the loop
condition will now be false and the loop will terminate. The value of
<em>fib1</em> will of course be <em>fib(i)</em> but now we’ll also have that <em>i ==
n</em> (it takes a little reasoning to prove this), so <em>fib(i)</em> will be
<em>fib(n)</em>, which is the result we want and that we return.</p>
<p>We can also informally prove to ourself that this strategy gives us
a program that always terminates and returns a value. That is, it does
not go into an infinite loop. To see this, note that the value of <em>i</em>
is initally less than or equal to <em>n</em>, and it increases by only <em>1</em> on
each time through the loop. The value of <em>n</em> is finite, so the value
of <em>i</em> will eventually equal the value of <em>n</em> at which point the loop
condition will be falsified and the looping will end.</p>
<p>That’s our strategy. So let’s go. Here’s the while loop that we have
designed. And here, for the first time, we see something crucial. We
tell Dafny about certain properties of the state of the program that
hold both before and after every execution of the loop body. We call
such properties <em>invariants</em>. Dafny needs to know these invariants to
prove to itself (and to us) that the loop does what it is intended to
do: that the result at the end will be as desired.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>while (i &lt; n)
    invariant i &lt;= n;
    invariant fib0 == fib(i-1);
    invariant fib1 == fib(i);
{
    var fib2 := fib0 + fib1;
    fib0 := fib1;
    fib1 := fib2;
    i := i + 1;
}
</pre></div>
</div>
<p>The invariants are just the conditions that we required to hold for
our design of the loop to work. First, <em>i</em> must never exceed <em>n</em>. If
it did, the loop would spin off into infinity. Second, to compute the
next (the <em>i+1st)</em> Fibonacci number we have to have the previous <em>two</em>
in memory. So <em>fib0</em> better hold <em>fib(i-1)</em> and <em>fib1</em>, <em>fib(i)</em>. Note
that these conditions do not have to hold <em>within</em> the execution of
the loop body, but they do have to hold before before and after each
execution.</p>
<p>The body of the loop is just as we described it above, and we can use
our own minds to deduce that if the invariants hold before the loop
body runs (and they do), then they will also hold after it runs. We
can also see that after the loop terminates, it must be that <em>i==n</em>.
This is because we know that it’s always true that <em>i &lt;= n</em> and the
loop condition must now be false, which is to say that <em>i</em> can no
longer be strictly less than <em>n</em>, so <em>i</em> must now equal <em>n</em>. Logic
says so, and logic is right. What is amazing is that we can write
these assertions in Dafny if we wish to, and Dafny will verify that
they are true statements about the state of the program after the
loop has run. We have <em>proved</em> (or rather Dafny has proved and we
have recapitulated the proof in this sequence of assertions) that
we have without a doubt computed the right answer. Dafny has also
proved to itself that the loop always terminates, and so we have
in effect a formal proof of total correctness for this program.</p>
<div class="highlight-dafny"><div class="highlight"><pre><span></span>assert i &lt;= n;      // invariant
assert !(i &lt; n);    // loop condition is false
assert (i &lt;= n) &amp;&amp; !(i &lt; n) ==&gt; (i == n);
assert i == n;      // deductive conclusion
assert fib1 == fib(i); // invariant
assert fib1 == fib(i) &amp;&amp; (i==n) ==&gt; fib1 == fib(n);
assert fib1 == fib(n);
return fib1;
</pre></div>
</div>
</div>
<div class="section" id="what-is-dafny">
<h2>What is Dafny?<a class="headerlink" href="#what-is-dafny" title="Permalink to this headline">¶</a></h2>
<p>Dafny is a cutting-edge software language and tooset developed at
Microsoft Research—one of the top computer science research labs in
the world—that provides such a capability. We will explore Dafny and
the ideas underlying it in the first part of this course, both to give
a sense of the current state of the art in program verification and,
most importantly, to explain why it’s vital for a computer scientist
today to have a substantial understanding of logic and proofs along
with the ability to <em>code</em>.</p>
<p>Tools such as TLA+, Dafny, and others of this variety give us a way
both to express formal specifications and imperative code in a unified
way (albeit in different sub-languages), and to have some automated
checking done in an <em>attempt</em> to verify that code satisfies its spec.</p>
<p>We say <em>attempt</em> here, because in general verifying the consistency of
code and a specification is a literally unsolvable problem. In cases
that arise in practice, much can often be done. It’s not always easy,
but if one requires ultra-high assurance of the consistency of code
and specification, then there is no choice but to employ the kinds of
<em>formal methods</em> introduced here.</p>
<p>To understand how to use such state-of-the-art software development
tools and methods, one must understand not only the language of code,
but also the languages of mathematical logic, including set and type
theory. One must also understand precisely what it means to <em>prove</em>
that a program satisfies its specification; for generating proofs is
exactly what tools like Dafny do <em>under the hood</em>.</p>
<p>A well educated computer scientist and a professionally trained
software developer must understand logic and proofs as well as coding,
and how they work together to help build <em>trustworthy</em> systems. Herein
lies the deep relevance of logic and proofs, which might otherwise
seem like little more than abstract nonsense and a distraction from
the task of learning how to program.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h4>Previous topic</h4>
  <p class="topless"><a href="04-runnable-math.html"
                        title="previous chapter">Pure Functional Programming as Runnable Mathematics</a></p>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="04-runnable-math.html" title="Pure Functional Programming as Runnable Mathematics"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">Mathematical Logic in Software Development 1 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2018, Kevin Sullivan.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.5.
    </div>
  </body>
</html>