%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
 \ifdefined\DeclareUnicodeCharacterAsOptional
  \DeclareUnicodeCharacter{"00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{"2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{"2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{"2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{"251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{"2572}{\textbackslash}
 \else
  \DeclareUnicodeCharacter{00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{2572}{\textbackslash}
 \fi
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage[dontkeepoldnames]{sphinx}

\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}


\usepackage{amsmath}
    \usepackage{cases}


\title{Mathematical Logic in Software Development Documentation}
\date{Feb 04, 2018}
\release{1}
\author{Kevin Sullivan}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex

\begin{document}

\maketitle
\sphinxtableofcontents
\phantomsection\label{\detokenize{index::doc}}



\chapter{Requirement, Specifications, and Implementations}
\label{\detokenize{01-reqs-specs-impls::doc}}\label{\detokenize{01-reqs-specs-impls:welcome-to-mathematical-logic-in-software-development}}\label{\detokenize{01-reqs-specs-impls:requirement-specifications-and-implementations}}
Software is an increasingly critical component of major societal
systems, from rockets to power grids to healthcare, etc. Failures are
not always bugs in implementation code. The most critical problems
today are not in implementations but in requirements and
specifications.
\begin{itemize}
\item {} 
\sphinxstylestrong{Requirements:} Statements of the effects that a system is meant to have in a given domain

\item {} 
\sphinxstylestrong{Specification:} Statements of the behavior required of a machine to produce such effects

\item {} 
\sphinxstylestrong{Implementation:} The definition (usually in code) of how a machine produces the specified behavior

\end{itemize}

Avoiding software-caused system failures requires not only a solid
understanding of requirements, specifications, and implementations,
but also great care in both the \sphinxstyleemphasis{validation} of requirements and of
specifications, and \sphinxstyleemphasis{verification} of code against specifications.
\begin{itemize}
\item {} 
\sphinxstylestrong{Validation:} \sphinxstyleemphasis{Are we building the right system?} is the specification right; are the requirements right?

\item {} 
\sphinxstylestrong{Verification:} \sphinxstyleemphasis{Are we building the system right?} Does the implementation behave as its specification requires?

\end{itemize}

You know that the language of implementation is code. What is the
language of specification and of requirements?

One possible answer is \sphinxstyleemphasis{natural language}. Requirements and
specifications can be written in natural languages such as English or
Mandarin. The problem is that natural language is subject to
ambiguity, incompleteness, and inconsistency. This makes it a risky
medium for communicating the precise behaviors required of complex
software artifacts.

The alternative to natural language that we will explore in this class
is the use of mathematical logic, in particular what we call propositional
logic, predicate logic, set theory, and the related field of type theory.

Propositional logic is a language of simple propositions. Propositions
are assertions that might or might not be judged to be true. For
example, \sphinxstyleemphasis{Tennys (the person) plays tennis} is actually a true
proposition (if we interpret \sphinxstyleemphasis{Tennys} to be the person who just played
in the French Open).  So is \sphinxstyleemphasis{Tennys is from Tennessee}. And because
these two propositions are true, so is the \sphinxstyleemphasis{compound} proposition (a
proposition built up from smaller propositions) that Tennys is from
Tennessee \sphinxstylestrong{and} Tennys plans tennis.

Sometimes we want to talk about whether different entities satisfy
give propositions. For this, we introduce propositions with parameters,
which we will call \sphinxstyleemphasis{properties}. If we take \sphinxstyleemphasis{Tennys} out of \sphinxstyleemphasis{Tennys
plays tennis} and replace his name by a variable, \sphinxstyleemphasis{P}, that can take
on the identify of any person, then we end up with a parameterized
proposition, \sphinxstyleemphasis{P plays tennis}. Substituting the name of any particular
person for \sphinxstyleemphasis{P} then gives us a proposition \sphinxstyleemphasis{about that person} that we
can judge to be true or false. A parameterized proposition thus gives
rise to a whole family of propositions, one for each possible value of
\sphinxstyleemphasis{P}.

Sometimes we write parameterized propositions so that they look like
functions, like this: \sphinxstyleemphasis{PlaysTennis(P)}. \sphinxstyleemphasis{PlaysTennis(Tennys)} is thus
the proposition, \sphinxstyleemphasis{Tennys plays Tennis} while \sphinxstyleemphasis{PlaysTennis(Kevin)} is
the proposition \sphinxstyleemphasis{Kevin plays Tennis}. For each possible person name,
\sphinxstyleemphasis{P}, there is a corresponding proposition, \sphinxstyleemphasis{PlaysTennis(P)}.

Some such propositions might be true. For instance,
\sphinxstyleemphasis{PlaysTennis(Tennys)} is true in our example. Others might be false. A
parameterized proposition thus encodes a \sphinxstyleemphasis{property} that some things
(here people) have and that others don’t have (here, the property of
\sphinxstyleemphasis{being a tennis player}).

A property, also sometimes called a \sphinxstyleemphasis{predicate}, thus also serves to
identify a \sphinxstyleemphasis{subset} of elements in a given \sphinxstyleemphasis{domain of discourse}. Here
the domain of discourse is the of all people. The subset of people who
actually do \sphinxstyleemphasis{play tennis} is exactly the set of people, P, for whom
\sphinxstyleemphasis{PlaysTennis(P)} is true.

We note briefly, here, that, like functions, propositions can have
multiple parameters. For example, we can generalize from \sphinxstyleemphasis{Tennys plays
Tennis **and*} Tennys is from Tennessee* to \sphinxstyleemphasis{P plays tennis and P is
from L,} where P ranges over people and L ranges over locations. We
call a proposition with two or more parameters a \sphinxstyleemphasis{relation}. A
relation picks out \sphinxstyleemphasis{combinations} of elements for which corresponding
properties are true. So, for example, the \sphinxstyleemphasis{pair} (Tennys, Tennessee)
is in the relation (set of \sphinxstyleemphasis{P-L} pairs) picked out by this
parameterized proposition. On the other hand, the pair, (Kevin,
Tennessee), is not, because Kevin is actually from New Hampshire, so
the proposition \sphinxstyleemphasis{Kevin plays tennis **and*} Kevin is from Tennessee*
is not true. More on relations later!


\chapter{Logical Specifications, Imperative Implementations}
\label{\detokenize{02-logic-and-code::doc}}\label{\detokenize{02-logic-and-code:logical-specifications-imperative-implementations}}
We’ve discussed requirements, specifications, and implementations as
distinct artifacts that serve distinct purposes. For good reasons,
these artifacts are usually written in different languages. Software
implementations are usually written in programming languages, and, in
particular, are usually written in \sphinxstyleemphasis{imperative} programming languages.
Requirements and specifications, on the other hand, are written either
in natural language, e.g., English, or in the language of mathematical
logic.

This unit discusses these different kinds of languages, why they are
used for different purposes, the advantages and disadvantages of each,
and why modern software development requires fluency in and tools for
handling artifacts written in multiple such languages. In particular,
the educated computer scientist and the capable software developer
must be fluent in the language of mathematical logic.


\section{Imperative Languages for Implementations}
\label{\detokenize{02-logic-and-code:imperative-languages-for-implementations}}
The language of implementations is code, usually written in what we
call an \sphinxstyleemphasis{imperative} programming language. Examples of such languages
include Python, Java, C++, and Javascript.

The essential property of an imperative language is that it is
\sphinxstyleemphasis{procedural}. Programs in these languages describe step-by-step
\sphinxstyleemphasis{procedures}, in the form of sequences of \sphinxstyleemphasis{commands}, for solving
given problem instances. Commands in turn operate (1) by reading,
computing with, and updating values stored in a \sphinxstyleemphasis{memory}, and (2) by
interacting with the world outside of the computer by executing input
and output (I/O) commands.

Input (or \sphinxstyleemphasis{read}) commands obtain data from \sphinxstyleemphasis{sensors.} Sensors include
mundane devices such as computer mice, trackpads, and keyboards. They
also include sensors for temperature, magnetism, vibration, chemicals,
biological agents, radiation, and face and license plate recognition,
and much more. Sensors convert physical phenomena in the world into
digital data that programs can manipulate. Computer programs can thus be
made to \sphinxstyleemphasis{compute about reality beyond the computing machine}.

Output (or \sphinxstyleemphasis{write}) commands turn data back into physical phenomena in
the world. The cruise control computer in a car is a good example.  It
periodically senses both the actual speed of the car and the desired
speed set by the driver. It then computes the difference and finally
finally it outputs data representing that difference to an \sphinxstyleemphasis{actuator}
that changes the physical accelerator and transmission settings of the
car to speed it up or slow it down. Computer programs can thus also be
made to \sphinxstyleemphasis{manipulate reality beyond the computing machine}.

A special part of the world beyond of the (core of a) computer is its
\sphinxstyleemphasis{memory}. A memory is to a computer like a diary or a notebook is to a
person: a place to \sphinxstyleemphasis{write} information at one point in time that can
then be \sphinxstyleemphasis{read} back later on. Computers use special actuators to write
data to memory, and special sensors to read it back from memory when
it is needed later on. Memory devices include \sphinxstyleemphasis{random access memory}
(RAM), \sphinxstyleemphasis{flash memory}, \sphinxstyleemphasis{hard drives}, \sphinxstyleemphasis{magnetic tapes}, \sphinxstyleemphasis{compact} and
\sphinxstyleemphasis{bluray} disks, cloud-based data storage systems such as Amazon’s \sphinxstyleemphasis{S3}
and \sphinxstyleemphasis{Glacier} services, and so forth.

Sequential progams describe sequences of actions involving reading of
data from sensors (including from memory devices), computing with this
data, and writing resulting data out to actuators (to memory devices,
display screens, and physical systems controllers). Consider the
simple assignment command, \sphinxstyleemphasis{x := x + 1}. It tells the computer to
first \sphinxstyleemphasis{read} in the value stored in the part of memory designated by
the variable, \sphinxstyleemphasis{x, to add one to that value, and finally to *write} the
result back out to the same location in memory. It’s as if the person
read a number from a notebook, computed a new number, and then erased
the original number and replaced it with the new number. The concept
of an updateable memory is at the very heart of the imperative model
of computation.


\section{Declarative Languages for Specifications}
\label{\detokenize{02-logic-and-code:declarative-languages-for-specifications}}
The language of formal requirements and specifications, on the other
hand, is not imperative code but \sphinxstyleemphasis{declarative} logic.  Expressions in
such logic will state \sphinxstyleemphasis{what} properties or relationships must hold in
given situation without providing a procedures that describes \sphinxstyleemphasis{how}
such results are to be obtained.

To make the difference between procedural and declarative styles of
description clear, consider the problem of computing the positive
square root of any given non-negative number, \sphinxstyleemphasis{x}. We can \sphinxstyleemphasis{specify}
the result we seek in a clear and precise logical style by saying
that, for any given non-negative number \sphinxstyleemphasis{x}, we require a value, \sphinxstyleemphasis{y},
such that \(y^2 = x\). Such a \sphinxstyleemphasis{y}, squared, gives \sphinxstyleemphasis{x}, and this
makes \sphinxstyleemphasis{y} a square root.

We would write this mathematically as \(\forall x \in {\mathbb R}
\mid x >= 0, y \in {\mathbb R} | y >= 0 \land y^2 = x\). In English,
we’d pronounce this expression as, “for any value, \sphinxstyleemphasis{x}, in the real
numbers, where \sphinxstyleemphasis{x} is greater than or equal to zero, the result is a
value, \sphinxstyleemphasis{y}, also in the real numbers, where \sphinxstyleemphasis{y} is greater than or
equal to zero and \sphinxstyleemphasis{y} squared is equal to \sphinxstyleemphasis{x}.” (The word, \sphinxstyleemphasis{where},
here is also often pronounced as \sphinxstyleemphasis{such that}. Repeat it to yourself
both ways until it feels natural to translate the math into spoken
English.)

Let’s look at this expression with care. First, the symbol,
\(\forall\), is read as \sphinxstyleemphasis{for all} or \sphinxstyleemphasis{for any}. Second, the symbol
\({\mathbb R}\), is used in mathematical writing to denote the set
of the \sphinxstyleemphasis{real numbers}, which includes the \sphinxstyleemphasis{integers} (whole numbers,
such as \sphinxstyleemphasis{-1}, \sphinxstyleemphasis{0}, and \sphinxstyleemphasis{2}), the rational numbers (such as \(2/3\)
and \sphinxstyleemphasis{1.5}), and the irrational numbers (such as \sphinxstyleemphasis{pi} and \sphinxstyleemphasis{e}). The
symbol, \(\in\), pronounced as \sphinxstyleemphasis{in}, represents membership of a
value, here \sphinxstyleemphasis{x}, in a given set. The expression, \(\forall x \in
{\mathbb R}\) thus means “for any value, \sphinxstyleemphasis{x}, in the real numbers,” or
just “for any real number, \sphinxstyleemphasis{x}”.

The vertical bar followed by the statement of the property, \sphinxstyleemphasis{x \textgreater{}= 0},
restricts the value being considered to one that satisfies the stated
property. Here the value of \sphinxstyleemphasis{x} is restricted to being greater than or
equal to zero. The formula including this constraint can thus be read
as “for any non-negative real number, \sphinxstyleemphasis{x}.” The set of non-negative
real numbers is thus selected as the \sphinxstyleemphasis{domain} of the function that we
are specifying.

The comma is our formula is a major break-point. It separates the
specification of the \sphinxstyleemphasis{domain} of the function from a formula, after
the comma, that specifies what value, if any, is associated with each
value in the domain.  You can think of the formula after the comma as
the \sphinxstyleemphasis{body} of the function. Here it says, assuming that \sphinxstyleemphasis{x} is any
non-negative real numner, that the associated value, sometimes called
the \sphinxstyleemphasis{image} of \sphinxstyleemphasis{x} under the function, is a value, \sphinxstyleemphasis{y}, also in the
real numbers (the \sphinxstyleemphasis{co-domain} of the function), such that \sphinxstyleemphasis{y} is both
greater than or equal to zero equal \sphinxstyleemphasis{and} \(y^2 = x\). The symbol,
\(\land\) is the logical symbol for \sphinxstyleemphasis{conjunction}, which is the
operation that composes two smaller propositions or properties into a
larger one that is true or satisfied if and only if both constituent
propositions or properties are. The formula to the right of the comma
thus picks out exactly the positive (or more accurate a non-negative)
square root of \sphinxstyleemphasis{x}.

We thus have a precise specification of the positive square root
function for non-negative real numbers. It is defined for every value
in the domain insofar as every non-negative real number has a positive
square root. It is also a \sphinxstyleemphasis{function} in that there is \sphinxstyleemphasis{at most one}
value for any given argument. If we had left out the non-negativity
\sphinxstyleemphasis{constraint} on \sphinxstyleemphasis{y} then for every \sphinxstyleemphasis{x} (except \sphinxstyleemphasis{0}) there would be
\sphinxstyleemphasis{two} square roots, one positive and one negative. We would then no
longer have a \sphinxstyleemphasis{function}, but rather a \sphinxstyleemphasis{relation}. A function must be
\sphinxstyleemphasis{single-valued}, with at most one “result” for any given “argument”.

We now have a \sphinxstyleemphasis{declarative specification} of the desired relationship
between \sphinxstyleemphasis{x} and \sphinxstyleemphasis{y}. The definition is clear (once you understand the
notation), it’s concise, it’s precise. Unfortunately, it isn’t what we
call \sphinxstyleemphasis{effective}. It doesn’t give us a way to actually \sphinxstyleemphasis{compute} the
value of the square root of any \sphinxstyleemphasis{x}. You can’t run a specification in
the language of mathematical logic (at least not in a practical way).


\section{Refining Declarative Specifications into Imperative Implementations}
\label{\detokenize{02-logic-and-code:refining-declarative-specifications-into-imperative-implementations}}
The solution is to \sphinxstyleemphasis{refine} our declarative specification, written in
the language of mathematical logic, into a computer program, written
in an imperative language: one that computes \sphinxstyleemphasis{exactly} the function we
have specified. To refine means to add detail while also preserving
the essential properties of the original. The details to be added are
the procedural steps required to compute the function. The essence to
be preserved is the value of the function at each point in its domain.

In short, we need a step-by-step procedure, in an imperative language,
that, when \sphinxstyleemphasis{evaluated with a given actual parameter value}, computes
exactly the specified value. Here’s a program that \sphinxstyleemphasis{almost} does the
trick. Written in the imperative language, Python, it uses Newton’s
method to compute \sphinxstyleemphasis{floating point} approximations of positive square
roots of given non-negative \sphinxstyleemphasis{floating point} arguments.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{k}{def} \PYG{n+nf}{sqrt}\PYG{p}{(}\PYG{n}{x}\PYG{p}{)}\PYG{p}{:}
    \PYG{l+s+sd}{\PYGZdq{}\PYGZdq{}\PYGZdq{}for x\PYGZgt{}=0, return non\PYGZhy{}negative y such that y\PYGZca{}2 = x\PYGZdq{}\PYGZdq{}\PYGZdq{}}
    \PYG{n}{estimate} \PYG{o}{=} \PYG{n}{x}\PYG{o}{/}\PYG{l+m+mf}{2.0}
    \PYG{k}{while} \PYG{n+nb+bp}{True}\PYG{p}{:}
        \PYG{n}{newestimate} \PYG{o}{=} \PYG{p}{(}\PYG{p}{(}\PYG{n}{estimate}\PYG{o}{+}\PYG{p}{(}\PYG{n}{x}\PYG{o}{/}\PYG{n}{estimate}\PYG{p}{)}\PYG{p}{)}\PYG{o}{/}\PYG{l+m+mf}{2.0}\PYG{p}{)}
        \PYG{k}{if} \PYG{n}{newestimate} \PYG{o}{==} \PYG{n}{estimate}\PYG{p}{:}
            \PYG{k}{break}
        \PYG{n}{estimate} \PYG{o}{=} \PYG{n}{newestimate}
    \PYG{k}{return} \PYG{n}{estimate}
\end{sphinxVerbatim}

This procedure initializes and then repeatedly updates the values
stored at two locations in memory, referred to by the two variables,
\sphinxstyleemphasis{estimate} and \sphinxstyleemphasis{newestimate}. It repeats the update process until the
process \sphinxstyleemphasis{converges} on the answer, which occurs when the values of the
two variables become equal. The answer is then returned to the caller
of this procedure.

Note that, following good programming style, we included an English
rendering of the specification as a document string in the second line
of the program.  There are however several problems using English or
other natural language comments to document specifications. First,
natural language is prone to ambiguity, inconsistency, imprecision,
and incompleteness. Second, because the document string is just a
comment, there’s no way for the compiler to check consistency between
the code and this specification. Third, in practice, code evolves (is
changed over time), and developers often forget, or neglect, to update
comments, so, even if an implementation is initially consistent with a
such a comment, inconsistencies can and often do develop over time.

In this case there is, in fact, a real, potentially catastrophic,
mathematical inconsistency between the specification and what the
program computes. The problem is that in Python, as in many everyday
programming languages, so-called \sphinxstyleemphasis{real} numbers are not exactly the
same as the real (\sphinxstyleemphasis{mathematical}) reals!

You can easily see what the problem is by using our procedure to
compute the square root of 2.0 and by then multiplying that number by
itself. The result of the computation is the number \sphinxstyleemphasis{1.41421356237},
which we already know has to be wrong to some degree, as the square
root of two is an \sphinxstyleemphasis{irrational} number that cannot be represented by
any non-terminating, non-repeating decimal. Indeed, if we multiply
this number by itself, we get the number, \sphinxstyleemphasis{1.99999999999}. We end up
in a situation in which \sphinxstyleemphasis{sqrt(2.0) * sqrt(2.0)} isn’t equal to 2.0!

The problem is that in Python, as in most industrial programming
languages, \sphinxstyleemphasis{so-called} real numbers (often called \sphinxstyleemphasis{floating point}
numbers) are represented in just 64 binary digits, and that permits
only a finite number of digits after the decimal to be represented.
And additional \sphinxstyleemphasis{low-order} bits are simply dropped, leading to what
we call \sphinxstyleemphasis{floating-point roundoff errors.} That’s what we’re seeing
here.

In fact, there are problems not only with irrational numbers but with
rational numbers with repeating decimal expansions when represented in
the binary notation of the IEEE-754 (2008) standard for floating point
arithmetic. Try adding \sphinxstyleemphasis{1/10} to itself \sphinxstyleemphasis{10} times in Python. You will
be surprised by the result. \sphinxstyleemphasis{1/10} is rational but its decimal form is
repeating in base-2 arithmetic, so there’s no way to represent \sphinxstyleemphasis{1/10}
precisely as a floating point number in Python, Java, or in many other
such languages.

There are two possible solutions to this problem. First, we could
change the specification to require only that \sphinxstyleemphasis{y} squared be very
close to \sphinxstyleemphasis{x} (within some specified margin of error). The we could
show that the code satisfies this approximate definition of square
root. An alternative would be to restrict our programming language to
represent real numbers as rational numbers, use arbitrarily large
integer values for numerators and denominators, and avoid defining any
functions that produce irrational values as results. We’d represent
\sphinxstyleemphasis{1/10} not as a 64-bit floating point number, for example, but simply
as the pair of integers \sphinxstyleemphasis{(1,10)}.

This is the solution that Dafny uses.  So-called real numbers in Dafny
behave not like \sphinxstyleemphasis{finite-precision floating point numbers that are only
approximate} in general, but like the \sphinxstyleemphasis{mathematical} real numbers they
represent. The limitation is that not all reals can be represented (as
values of the \sphinxstyleemphasis{real} type in Dafny. In particular, irrational numbers
cannot be represented exactly as real numbers. (Of course they can’t
be represented exactly by IEEE-754 floating point numbers, either.) If
you want to learn (a lot) more about floating point, or so-called
\sphinxstyleemphasis{real}, numbers in most programming languages, read the paper by David
Goldberg entitled, \sphinxstyleemphasis{What Every Computer Scientist Should Know About
Floating-Point Arithmetic.} It was published in the March, 1991 issue
of Computing Surveys. You can find it online.


\section{Why Not a Single Language for Programming and Specification?}
\label{\detokenize{02-logic-and-code:why-not-a-single-language-for-programming-and-specification}}
The dichotomy between specification logic and implementation code
raises an important question? Why not just design a single language
that’s good for both?

The answer is that there are fundamental tradeoffs in language design.
One of the most important is a tradeoff between \sphinxstyleemphasis{expressiveness}, on
one hand, and \sphinxstyleemphasis{efficient execution}, on the other.

What we see in our square root example is that mathematical logic is
highly \sphinxstyleemphasis{expressive}. Logic language can be used so say clearly \sphinxstyleemphasis{what}
we want. On the other hand, it’s hard using logic to say \sphinxstyleemphasis{how} to get
it. In practice, mathematical logic is clear but can’t be \sphinxstyleemphasis{run} with
the efficiency required in practice.

On the other hand, imperative code states \sphinxstyleemphasis{how} a computation is to be
carried out, but generally doesn’t make clear \sphinxstyleemphasis{what} it computes. One
would be hard-pressed, based on a quick look at the Python code above,
for example, to explain \sphinxstyleemphasis{what} it does (but for the comment, which is
really not part of the code).

We end up having to express \sphinxstyleemphasis{what} we want and \sphinxstyleemphasis{how} to get it in two
different languages. This situation creates a difficult new problem:
to verify that a program written in an imperative language satisfies,
or \sphinxstyleemphasis{refines}, a specification written in a declarative language.  How
do we know, \sphinxstyleemphasis{for sure}, that a program computes exactly the function
specified in mathematical logic?

This is the problem of program \sphinxstyleemphasis{verification}. We can \sphinxstyleemphasis{test} a program
to see if it produces the specified outputs for \sphinxstyleemphasis{some} elements of the
input domain, but in general it’s infeasible to test \sphinxstyleemphasis{all} inputs. So
how can we know that we have \sphinxstyleemphasis{built a program} right, where right is
defined precisely by a formal (mathematical logic) specification) that
requires that a program work correctly for all (\(\forall\)) inputs?


\chapter{Problems with Imperative Code}
\label{\detokenize{03-problems-with-imperative-code:problems-with-imperative-code}}\label{\detokenize{03-problems-with-imperative-code::doc}}
There’s no free lunch: One can have the expressiveness of mathematical
logic, useful for specification, or one can have the ability to run
code efficiently, along with indispensable ability to interact with an
external environment provided by imperative code, but one can not have
all of this at once at once.

A few additional comments about expressiveness are in order here. When
we say that imperative programming languages are not as expressive as
mathematical logic, what we mean is not ony that the code itself is not
very explicit about what it computes. It’s also that it is profoundly
hard to fully comprehend what imperative code will do when run, in large
part due precisely to the things that make imperative code efficient: in
particular to the notion of a mutable memory.

One major problem is that when code in one part of a complex program
updates a variable (the \sphinxstyleemphasis{state} of the program), another part of the
code, far removed from the first, that might not run until much later,
can read the value of that very same variable and thus be affected by
actions taken much earlier by code far away in the program text. When
programs grow to thousands or millions of lines of code (e.g., as in
the cases of the Toyota unintended acceleration accident that we read
about), it can be incredibly hard to understand just how different and
seemingly unrelated parts of a system will interact.

As a special case, one execution of a procedure can even affect later
executions of the same procedure. In pure mathematics, evaluating the
sum of two and two \sphinxstyleemphasis{always} gives four; but if a procedure written in
Python updates a \sphinxstyleemphasis{global} variable and then incoporates its value into
the result the next time the procedure is called, then the procedure
could easily return a different result each time it is called even if
the argument values are the same. The human mind is simply not powerful
enough to see what can happen when computations distant in time and in
space (in the sense of being separated in the code) interact with each
other.

A related problem occurs in imperative programs when two different
variables, say \sphinxstyleemphasis{x} and \sphinxstyleemphasis{y}, refer to the same memory location. When
such \sphinxstyleemphasis{aliasing} occurs, updating the value of \sphinxstyleemphasis{x} will also change the
value of \sphinxstyleemphasis{y}, even though no explicit assignment to \sphinxstyleemphasis{y} was made. A
piece of code that assumes that \sphinxstyleemphasis{y} doesn’t change unless a change is
made explicitly might fail catastrophically under such circumstances.
Aliasing poses severe problems for both human understanding and also
machine analysis of code written in imperative languages.

Imperative code is thus potentially \sphinxstyleemphasis{unsafe} in the sense that it can
not only be very hard to fully understand what it’s going to do, but
it can also have effects on the world, e.g., by producing output
directing some machine to launch a missile, fire up a nuclear reactor,
steer a commercial aircraft, etc.


\chapter{Pure Functional Programming as Runnable Mathematics}
\label{\detokenize{04-runnable-math::doc}}\label{\detokenize{04-runnable-math:pure-functional-programming-as-runnable-mathematics}}
What we’d really like would be a language that gives us everything:
the expressiveness and the \sphinxstyleemphasis{safety} of mathematical logic (there’s no
concept of a memory in logic, and thus no possibility for unexpected
interactions through or aliasing of memory), with the efficiency and
interactivity of imperative code. Sadly, there is no such language.

Fortunately, there is an important point in the space between these
extremes: in what we call \sphinxstyleemphasis{pure functional,} as opposed to imperative,
\sphinxstyleemphasis{programming} languages. Pure functional languages are based not on
commands that update memories and perform I/O, but on the definition
of functions and their application to data values. The expressiveness
of such languages is high, in that code often directly refects the
mathematical definitions of functions. And because there is no notion
of an updateable (mutable) memory, aliasing and interactions between
far-flung parts of programs through \sphinxstyleemphasis{global variables} simply cannot
happen. Furthermore, one cannot perform I/O in such languages. These
languages thus provide far greater safety guarantees than imperative
languages.  Finally, unlike mathematical logic, code in functional
languages can be run with reasonable efficiency, though often not with
the same efficiency as in, say, C++.

In this chapter, you will see how functional languages allow one to
implement runnable programs that closely mirror the mathematical
definitions of the functions that they implement.


\section{The identify function (for integers)}
\label{\detokenize{04-runnable-math:the-identify-function-for-integers}}
An \sphinxstyleemphasis{identity function} is a function whose values is simply the value
of the argument to which it is applied. For example, the identify
function applied to an integer value, \sphinxstyleemphasis{x}, just evaluates to the value
of \sphinxstyleemphasis{x}, itself. In the language of mathematical logic, the definition
of the function would be written like this.
\begin{equation*}
\begin{split}\forall x \in \mathbb{Z}, x.\end{split}
\end{equation*}
In English, this would be pronounced, “for all (\(\forall\))
values, \sphinxstyleemphasis{x}, in (\(\in\)) the set of integers
(\(\mathbb{Z}\)), the function simply reduces to value of \sphinxstyleemphasis{x},
itself. The infinite set of integers is usually denoted in
mathematical writing by a script or bold Z. We will use that
convention in these notes.

While such a mathematical definition is not “runnable”, we can
\sphinxstyleemphasis{implement} it as a runnable program in pure functional language. The
code will then closely reflects the abstract mathematical definition.
And it will run!  Here’s an implementation of \sphinxstyleemphasis{id} written in the
functional sub-language of Dafny.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
function method id (x: int): int \PYGZob{} x \PYGZcb{}
\end{sphinxVerbatim}

The code declares \sphinxstyleemphasis{id} to be what Dafny calls a “function method”,
which indicates two things.  First, the \sphinxstyleemphasis{function} keyword states that
the code will be written in a pure functional, not in an imperative,
style. Second, the \sphinxstyleemphasis{method} keyword instructs the compiler to produce
runnable code for this function.

Let’s look at the code in detail. First, the name of the function is
defined to be \sphinxstyleemphasis{id}. Second, the function is defined to take just one
argument, \sphinxstyleemphasis{x}, declared of type \sphinxstyleemphasis{int}.  The is the Dafny type whose
values represent integers (negative, zero, and positive whole number)
of any size. The Dafny type \sphinxstyleemphasis{int} thus represents (or \sphinxstyleemphasis{implements})
the mathematical set, \({\mathbb Z}\), of all integers. The \sphinxstyleemphasis{int}
after the argument list and colon then indicates that, when applied to
an int, the function returns (or \sphinxstyleemphasis{reduces to}) a value of type \sphinxstyleemphasis{int}.
Finally, within the curly braces, the expression \sphinxstyleemphasis{x}, which we call
the \sphinxstyleemphasis{body} of this function definition, specifies the value that this
function reduces to when applied to any \sphinxstyleemphasis{int}. In particular, when
applied to avalue, \sphinxstyleemphasis{x}, the function application simply reduces to the
value of \sphinxstyleemphasis{x} itself.

Compare the code with the abstract mathematical definition and you
will see that but for details, they are basicaly \sphinxstyleemphasis{isomorphic} (a word
that means identical in structure). It’s not too much of a stretch to
say that pure functional programs are basically runnable mathematics.

Finally, we need to know how expressions involving applications of
this function to arguments are evaluated. They fundamental notion at
the heart of functional programming is this: to evaluate a function
application expression, such as \sphinxstyleemphasis{id(4)}, you substiute the value of
the argument (here \sphinxstyleemphasis{4}) for every occurence of the argument variable
(here \sphinxstyleemphasis{x}) in the body of the function definition, the you evaluate
that expression and return the result. In this case, we substite \sphinxstyleemphasis{4}
for the \sphinxstyleemphasis{x} in the body, yielding the literal expression, \sphinxstyleemphasis{4}, which,
when evaluated, yeilds the value \sphinxstyleemphasis{4}, and that’s the result.


\section{Data and function types}
\label{\detokenize{04-runnable-math:data-and-function-types}}
Before moving on to more interesting functions, we must mention the
concepts of \sphinxstyleemphasis{types} and \sphinxstyleemphasis{values} as they pertain to both \sphinxstyleemphasis{data} and
\sphinxstyleemphasis{functions}. Two types appear in the example of the \sphinxstyleemphasis{id} function. The
first, obvious, one is the type \sphinxstyleemphasis{int}. The \sphinxstyleemphasis{values} of this type are
\sphinxstyleemphasis{data} values, namely values representing integers. The second type,
which is less visible in the example, is the type of the the function,
\sphinxstyleemphasis{id}, itself. As the function takes an argument of type \sphinxstyleemphasis{int} and also
returns a value of type \sphinxstyleemphasis{int}, we say that the type of \sphinxstyleemphasis{id} is
\(int \rightarrow int\). You can pronounce this type as \sphinxstyleemphasis{int to
int}.


\section{Other function values of the same type}
\label{\detokenize{04-runnable-math:other-function-values-of-the-same-type}}
There are many (indeed an uncountable infinity of) functions that
convert integer values to other integer values. All such functions
have the same type, namely \(int \rightarrow int\), but they
constitute different function \sphinxstyleemphasis{values}. While the type of a function
is specified in the declaration of the function argument and return
types, a function \sphinxstyleemphasis{value} is defined by the expression comprising the
\sphinxstyleemphasis{body} of the function.

An example of a different function of the same type is what we will
call \sphinxstyleemphasis{inc}, short for \sphinxstyleemphasis{increment}. When applied to an integer value,
it reduces to (or \sphinxstyleemphasis{returns}) that value plus one. Mathematically, it
is defined as \(\forall x \in {\mathbb Z}, x + 1\). For example,
\sphinxstyleemphasis{inc(2)} reduces to \sphinxstyleemphasis{3}, and \sphinxstyleemphasis{inc(-2)}, to \sphinxstyleemphasis{-1}.

Here’s a Dafny functional program that implements this function. You
should be able to understand this program with ease. Once again, take
a moment to see the relationship between the abstract mathematical
definition and the concrete code. They are basically isomorphic. The
pure functional programmer is writing \sphinxstyleemphasis{runnable mathematics}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
function method inc (x: int): int \PYGZob{} x + 1 \PYGZcb{}
\end{sphinxVerbatim}

Another example of a function of the same type is, \sphinxstyleemphasis{square}, defined
as returing the square of its integer argument. Mathematically it is
the function, \(\forall x \in {\mathbb Z}, x * x\). And here is
a Dafny implementation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
function method h (x: int): int \PYGZob{} x * x \PYGZcb{}
\end{sphinxVerbatim}

Evaluating expressions in which this function is applied to an
argument happens as previously described. To evaluate \sphinxstyleemphasis{square(4)}, for
example, you rewrite the body, \sphinxstyleemphasis{x * x}, replacing every \sphinxstyleemphasis{x} with a
\sphinxstyleemphasis{4}, yielding the expression \sphinxstyleemphasis{4 * 4}, then you evaluate that
expression and return the result, here \sphinxstyleemphasis{16}. Function evaluation is
done by substituting actual parameter values for all occurrences of
corresponding formal parameters in the body of a function, evaluating
the resulting expression, and returning that result.


\section{Recursive function definitions and implementations}
\label{\detokenize{04-runnable-math:recursive-function-definitions-and-implementations}}
Many mathematical functions are defined \sphinxstyleemphasis{recursively}. Consider the
familiar \sphinxstyleemphasis{factorial} function. An informal explanation of what the
function produces when applied to a natural number (a non-negative
integer), \sphinxstyleemphasis{n}, is the product of natural numbers from \sphinxstyleemphasis{1} to \sphinxstyleemphasis{n}.

That’s a perfectly understandable definition, but it’s not quite
precise (or even correct) enough for a mathematician. There are at
least two problems with this definition. First, it does not define the
value of the function \sphinxstyleemphasis{for all} natural numbers. In particular, it
does not say what the value of the function is for zero. Second, you
can’t just extend the definition by saying that it yields the product
of all the natural numbers from zero to \sphinxstyleemphasis{n}, because that is always
zero!

Rather, if the function is to be defined for an argument of zero, as
we require, then we had better define it to have the value one when
the argument is zero, to preserve the product of all the other numbers
larger than zero that we might have multiplied together to produce the
result. The trick is to write a mathematical definition of factorial
in two cases: one for the value zero, and one for any other number.
\begin{equation*}
\begin{split}factorial(n) := \forall n \in {\mathbb Z} \mid n >= 0, \begin{cases}
\text{if n=0}, & 1,\\ \text{otherwise}, & n *
factorial(n-1).\end{cases}\end{split}
\end{equation*}
To pronounce this mathematical definition in English, one would say
that for any integer, \sphinxstyleemphasis{n}, such that \sphinxstyleemphasis{n} is greater than or equal to
zero, \sphinxstyleemphasis{factorial(n)} is one if \sphinxstyleemphasis{n} is zero and is otherwise \sphinxstyleemphasis{n} times
\sphinxstyleemphasis{factorial(n-1)}.

Let’s analyze this definition. First, whereas in earlier examples we
left mathematical definitions anonymous, here we have given a name,
\sphinxstyleemphasis{factorial}, to the function, as part of its mathematical definition.
We have to do this because we need to refer to the function within its
own definition.  When a definition refers to the thing that is being
defined, we call the definition \sphinxstyleemphasis{recursive.}

Second, we have restricted the \sphinxstyleemphasis{domain} of the function, which is to
say the set of values for which it is defined, to the non-negative
integers only, the set known as the \sphinxstyleemphasis{natural numbers}. The function
simply isn’t defined for negative numbers.  Mathematicians usually use
the symbol, \({\mathbb N}\) for this set. We could have written
the definition a little more concisely using this notation, like this:
\begin{equation*}
\begin{split}factorial(n) := \forall n \in {\mathbb N}, \begin{cases}
\text{if n=0}, & 1,\\ \text{otherwise}, & n *
factorial(n-1).\end{cases}\end{split}
\end{equation*}
Here, then, is a Dafny implementation of the factorial function.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
function method fact(n: int): int
   requires n \PYGZgt{}= 0 // for recursion to be well founded
\PYGZob{}
    if (n==0) then 1
    else n * fact(n\PYGZhy{}1)
\PYGZcb{}
\end{sphinxVerbatim}

This code exactly mirrors our first mathematical definition. The
restriction on the domain is expressed in the \sphinxstyleemphasis{requires} clause of the
program. This clause is not runnable code. It’s a specification: a
\sphinxstyleemphasis{predicate} (a proposition with a parameter) that must hold for the
program to be used. Dafny will insist that this function only ever be
applied to values of \sphinxstyleemphasis{n} that have the \sphinxstyleemphasis{property} of being \(>=
0\). A predicate that must be true for a program to be run is called a
\sphinxstyleemphasis{pre-condition}.

To see how the recursion works, consider the application of
\sphinxstyleemphasis{factorial} to the natural number, \sphinxstyleemphasis{3}. We know that the answer should
be \sphinxstyleemphasis{6. The evaluation of the expression, *factorial(3)}, works as for
any function application expression: first you subsitute the value of
the argument(s) for each occurrence of the formal parameters in the
body of the function; then you evaluate the resulting expression
(recursively!) and return the result. For \sphinxstyleemphasis{factorial(3)}, this process
leads through a sequence of intermediate expressions as follows (leaving
out a few details that should be easy to infer):
\begin{align*}\!\begin{aligned}
factorial\ (3) & \text{ ; a function application expression}\\
if\ (3 == 0)\ then\ 1\ else\ (3 * factorial\ (3-1)) & \text{ ; expand body with  parameter/argument substitution}\\
if\ (3 == 0)\ then\ 1\ else\ (3 * factorial\ (2))  & \text{ ; evaluate $(3-1)$}\\
if\ false\ then\ 1\ else\ (3 * factorial\ (2)) & \text{ ; evaluate $(3==0)$ }\\
(3 * factorial\ (2)) & \text{ ; evaluate $ifThenElse$ }\\
(3 * (if\ (2==0)\ then\ 1\ else\ (2 * factorial\ (1))) & \text{ ; etc }\\
(3 * (2 * factorial\ (1))\\
(3 * (2 * (if\ (1==0)\ then\ 1\ else\ (1 * factorial\ (0)))))\\
(3 * (2 * (1 * factorial\ (0))))\\
(3 * (2 * (1 * (if\ (0==0)\ then\ 1\ else\ (0 * factorial\ (-1))))))\\
(3 * (2 * (1 * (if\ true\ then\ 1\ else\ (0 * factorial\ (-1))))))\\
(3 * (2 * (1 * 1)))\\
(3 * (2 * 1))\\
(3 * 2)\\
6\\
\end{aligned}\end{align*}
The evaluation process continues until the function application expression
is reduced to a data value. That’s the answer!

It’s important to understand how recursive function application
expressions are evaluated. Study this example with care. Once you’re
sure you see what’s going on, go back and look at the mathematical
definition, and convince yourself that you can understand it \sphinxstyleemphasis{without}
having to think about \sphinxstyleemphasis{unrolling} of the recursion as we just did.

Finally we note that the the precondition is essential. If it were not
there in the mathematical definition, the definition would not be what
mathematicians call \sphinxstyleemphasis{well founded}: the recursive definition might
never stop looping back on itself. Just think about what would happen
if you could apply the function to \sphinxstyleemphasis{-1}. The definition would involve
the function applied to \sphinxstyleemphasis{-2}. And the definition of that would involve
the function applied to \sphinxstyleemphasis{-3}. You can see that there will be an
infinite regress.

Similarly, if Dafny would allow the function to be applied to \sphinxstyleemphasis{any}
value of type \sphinxstyleemphasis{int}, it would be possible, in particular, to apply the
function to negative values, and that would be bad!  Evaluating the
expression, \sphinxstyleemphasis{factorial(-1)} would involve the recursive evaluation of
the expression, \sphinxstyleemphasis{factorial(-2)}, and you can see that the evaluation
process would never end. The program would go into an “infinite loop”
(technically an unbounded recursion). By doing so, the program would
also violate the fundamental promise made by its type: that for \sphinxstyleemphasis{any}
integer-valued argument, an integer result will be produced. That can
not happen if the evaluation process never returns a result. We see
the precondition in the code, implementing the domain restriction in
the mathematical definition, is indispensible. It makes the definition
sound and it makes the code correct!


\section{Dafny is a Program Verifier}
\label{\detokenize{04-runnable-math:dafny-is-a-program-verifier}}
Restricting the domain of factorial to non-negative integers is
critical. Combining the non-negative property of ever value to which
the function is applied with the fact that every recursive application
is to a smaller value of \sphinxstyleemphasis{n}, allows us to conclude that no \sphinxstyleemphasis{infinite
decreasing chains} are possible. Any application of the function to a
non-negative integer \sphinxstyleemphasis{n} will terminate after exactly \sphinxstyleemphasis{n} recursive
calls to the function. Every non-negative integer, \sphinxstyleemphasis{n} is finite. So
every call to the function will terminate.

Termination is a critical \sphinxstyleemphasis{property} of programs. The proposition that
our factorial program with the precondition in place always terminates
is true as we’ve argued. Without the precondition, the proposition is
false.

Underneath Dafny’s “hood,” it has a system for proving propositions
about (i.e., properties of) programs. Here we see that It generates a
propostion that each recursive function terminates; and it requires a
proof that each such proposition is true.

With the precondition in place, there not only is a proof, but Dafny
can find it on its own. If you remove the precondition, Dafny won’t be
able to find a proof, because, as we just saw, there isn’t one: the
proposition that evaluation of the function always terminates is not
true. In this case, because it can’t prove termination, Dafny will
issue an error stating, in effect, that there is the possibility that
the program will infinitely loop. Try it in Dafny.  You will see.

In some cases there will be proofs of important propositions that
Dafny nevertheless can’t find it on its own. In such cases, you may
have to help it by giving it some additional propositions that it
can verify and that help point it in the right direction. We’ll see
more of this later.

The Dafny language and verification system is powerful mechansim for
finding subtle bugs in code, but it require a knowledge of more than
just programming. It requires an understanding of specification, and
of the languages of logic and proofs in which specifications of code
are expressed and verified.


\chapter{Integrating Formal Specification with Imperative Programming}
\label{\detokenize{05-putting-it-together::doc}}\label{\detokenize{05-putting-it-together:integrating-formal-specification-with-imperative-programming}}
We address such problems by combining a few ideas. First, we use logic
to express \sphinxstyleemphasis{declarative} specifications that precisely define \sphinxstyleemphasis{what} a
given imperative program must do while \sphinxstyleemphasis{abstracting from}
implementation details. Second, we implement the specified program in
a way that uses and that supports logical reasoning about its
behavior. Finally, we use logic proof techniques (or tools that do it
for us) to \sphinxstyleemphasis{formally verify} that the program satisifies its specification.


\section{Logical Specification}
\label{\detokenize{05-putting-it-together:logical-specification}}
First, we use mathematical logic to \sphinxstyleemphasis{declaratively specify} properties
of the behaviors that we require of programs written in \sphinxstyleemphasis{imperative}
languages. For example, we might require that, when given any natural
number, \$n\$, a program compute and return the value of the \$factorial\$
of \$n\$, the mathematical definition of which we’ve given as \$fact(n)\$.

Specifications about required relationships between argument values
and return results are especially important. They specify \sphinxstyleemphasis{what} a
program must compute without specifying how. Specifications are thus
\sphinxstyleemphasis{abstract}: they omit \sphinxstyleemphasis{implementation details}, leaving it to the
programmer to decide how best to \sphinxstyleemphasis{refine} the specification into a
working program.

For example we might specify that a program (1) must accept any
integer valued argument greater than or equal to zero (a piece of a
specification that we call a \sphinxstyleemphasis{precondition}), and (2) that as long as
the precondition holds, then it must return the factorial of the given
argument value (a \sphinxstyleemphasis{postcondition}).

In purely mathematical terms, a specification of this kind defines a
\sphinxstyleemphasis{binary relation} between argument and return values, and imposes on
the program a requirement that whenever it is given the first value in
such a pair, it must compute a second value so that the \((first
value, second value)\) pair is in the specified relation.

A binary relation in ordinary mathematics is just a set of pairs of
values. A function is a special binary relation with at most one pair
with a given first value. A function is said to be a \sphinxstyleemphasis{single-valued}
relation.

For example, pairs of non-negative integers in the relation that
constitutes the factorial function include \((0,1), (1,1), (2,2),
(3,6), (4,24)\) and \((5,120)\), but not \((5,25)\).

On the other hand, square root is a relation but not a \sphinxstyleemphasis{function}. It
is not singled valued. Both \((4,2)\) and \((4,-2)\), two
pairs with the same first element but different second elements, are
in the relation. That is because both \sphinxstyleemphasis{2} and \sphinxstyleemphasis{-2} are squarer roots
of \sphinxstyleemphasis{4}.  The \sphinxstyleemphasis{positive square root} relation, on the other hand, is a
function, comprising those pairs in the square root relation where
both elements are non-negative. It thus includes \((4,2)\) but
not  \((4,-2)\).

We could formulate the square root \sphinxstyleemphasis{relation} as a \sphinxstyleemphasis{function} in a
different way: by viewing it as a relation that associates with each
non-negative integer the single \sphinxstyleemphasis{set} of its square roots. The pair
\((4, \{2, -2\}\) is in this relation, for example. The relation is
now also a function in that there is only one such pair with a given
first element.

Now what we mean when we say that a program computes a function or a
relation is that whenever it is given a valid argument representing
the \sphinxstyleemphasis{first} value of a pair in the relation, it computes a \sphinxstyleemphasis{second}
value such that the pair, \((first, second)\) is in the given
relation. When we say, for example, that a program \sphinxstyleemphasis{computes the
factorial function}, we mean that if we give it a non-negative number,
\sphinxstyleemphasis{n}, it returns a number \sphinxstyleemphasis{m} such that the pair \sphinxstyleemphasis{(n,m)} is \sphinxstyleemphasis{in} the
relation. And for \sphinxstyleemphasis{(n,m)} to be in the relation it must be that
\(m = fact(n)\). The program thus has to return \(fact(n)\).

A program that computes a \sphinxstyleemphasis{function} is deterministic, in the sense
that it can return at most one result: because there is at most one
result. When a program computes a relation that is not a function, it
can return any value, \sphinxstyleemphasis{m}, where \sphinxstyleemphasis{(n,m)} is in the specified relation.


\section{Rigorous Implementation}
\label{\detokenize{05-putting-it-together:rigorous-implementation}}
Having written a formal specification of the required \sphinxstyleemphasis{input-output}
behavior of a program, we next write imperative code in a manner, and
in a language, that supports the use of formal logic to \sphinxstyleemphasis{reason} about
whether the program refines (implements) its formal specification. One
can use formal specifications when programming in any language, but it
helps greatly if the language has strong, static type checking. It is
even better if the language supports formal specification and logical
reasoning mechanisms right alongside of its imperative and functional
programming capabilities. Dafny is such a language.

In addition to choosing a language with features that help to support
formal reasoning (such as strong, static typing), we sometimes also
aim to write imperative code in a way that makes it easier to reason
about formally (using mathematical logic). As we will see below, for
example, the way that we write our while loops can make it easier or
harder to reason about their correctness.


\section{Formal Verification}
\label{\detokenize{05-putting-it-together:formal-verification}}
Our ultimate aim to deduce that, as written, a program satisfies its
input-output specification.  In more detail, if we’re given a program,
\sphinxstyleemphasis{C} with a precondition, \sphinxstyleemphasis{P}, and a postcondition \sphinxstyleemphasis{Q}, we want a proof
that verifies that if \sphinxstyleemphasis{C} is started in a state that satisfies \sphinxstyleemphasis{P} and
if it terminates (doesn’t go into an infinite loop), that it ends in a
state that satisfies \sphinxstyleemphasis{Q}. We call this property \sphinxstyleemphasis{partial correctness}.

We write the proposition that \sphinxstyleemphasis{C} is partially correct in this sense
(that if it’s started in a state that satisfies the assertion, \sphinxstyleemphasis{P},
and if it terminates then, it will do so in a state that satisfies
\sphinxstyleemphasis{Q}) as \(P {C} Q.\) This is a so-called \sphinxstyleemphasis{Hoare triple} (named
after the famous computer scientist, Sir Anthony (Tony) Hoare. It is
nothing other than a proposition that claims that \sphinxstyleemphasis{C} satisfies its
specification.

In addition to a proof of partial correctness, we usually do want to
know that a program also does always terminate. When we have a proof
of both \(P \{C\} Q\) and that the program always terminates, then
we have a proof of \sphinxstyleemphasis{total correctness}. Dafny is a programming system
that allows us to specify \sphinxstyleemphasis{P} amd \sphinxstyleemphasis{Q} and that then formally, and to a
considerable extent automatically, verifies \sphinxtitleref{P \{C\} Q} and termination.
That is, Dafny produces proofs of total correctness.

It is important to bear in mind that a proof that a program refines
its formal specification does not necessarily mean that it is fit for
its intended purpose! If the specification is wrong, then all bets are
off, even if the program is correct relative to its specification.
The problem of \sphinxstyleemphasis{validating} specification againts real-world needs is
separate from that of \sphinxstyleemphasis{verifying} that a given program implements its
specification correctly.


\section{Case Study: Implementing the Factorial Function}
\label{\detokenize{05-putting-it-together:case-study-implementing-the-factorial-function}}
So far the material in this chapter has been pretty abstract. Now
we’ll see what it means in practice. To start, let’s consider an
ordinary imperative program, as you might have written in Python or
Java, for computing the factorial function. The name of the function
is the only indication of the intended behavior of this program. There
is no documented specification. The program takes an argument of type
nat (which guarantees that the argument has the property of being
non-negative). It then returns a nat which the programmer implicitly
claims (given the function name) is the factorial of the argument.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
method factorial(n: nat) returns (f: nat)
\PYGZob{}
    if (n == 0)
    \PYGZob{}
        return 1;
    \PYGZcb{}
    var t: nat := n;
    var a: nat := 1;
    while (t !=  0)
    \PYGZob{}
        a := a * n;
        t := t \PYGZhy{} 1;
    \PYGZcb{}
    f := a;
\PYGZcb{}
\end{sphinxVerbatim}

Sadly, this program contains a bug. Try to find it. Reason about the
behavior of the program when the argument is 0, 1, 2, 3, etc.  Does it
always compute the right result? Where is the bug? What is wrong? And
how could this logical error have been detected automatically?

The problem is that the program lacks a complete specification. The
program does \sphinxstyleemphasis{something}, taking a nat and possibly returning a nat
(unless it goes into an infinite loop) but there’s no way to analyze
its correctness in the absence of a specification that defines what
\sphinxstyleemphasis{right} even means.

Now let’s see what happens when we make the specification complete.
The precondition will continue to be expressed by the type of the
argument, \sphinxstyleemphasis{n}, being \sphinxstyleemphasis{nat}. However, we have added a postcondition
that requires the return result to be the factorial of \sphinxstyleemphasis{n}. Note that
we used our functional definition of the \sphinxstyleemphasis{factorial} function in the
\sphinxstyleemphasis{specification} of our imperative code. The pure functional program is
really just a mathematical definition of factorial. What we assert
with the postcondition is thus that the imperative program computes
the factorial function as it is defined in pure mathematics.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
method factorial(n: nat) returns (f: nat)
    ensures f == fact(n)
\PYGZob{}
    if (n == 0)
    \PYGZob{}
        return 1;
    \PYGZcb{}
    var t := n;
    var a := 1;
    while (t !=  0)
    \PYGZob{}
        a := a * n;
        t := t \PYGZhy{} 1;
    \PYGZcb{}
    return a;
\PYGZcb{}
\end{sphinxVerbatim}

Dafny now reports that it cannot guarantee—formally prove to
itself—that the \sphinxstyleemphasis{postcondition} is guaranteed to hold. Generating
proofs is hard, not only for people but also for machines. In fact,
one of seminal results of 20th century mathematical logic was to prove
that there is no general-purpose algorithm for proving propositions in
mathematical logic. That’s good news for mathematicians!  If this
weren’t true, we wouldn’t need them!

So, the best that a machine can do is to try to find a proof for any
given proposition. Sometimes proofs are easy to generate. For example,
it’s easy to prove \sphinxstyleemphasis{1 = 1} by the \sphinxstyleemphasis{reflexive} propery of equality.
Other propositions can be hard to prove. Proving that programs in
imperative languages satisfy declarative specifications can be hard.

When Dafny fails to verify a program (find a proof that it satisfies
its specification), there is one of two reasons. Either the program
really does fail to satisfy its specificaiton; or the program is good
but Dafny does not have enough information to know how to prove it.

With the preceding program, the postcondition really isn’t satisfied
due to the bug in the program. But even if the program were correct,
Dafny would need a little more information than is given in this code
to prove it. In particular, Dafny would need a litte more information
about how the while loop behaves. It turns out that providing extra
information about while loops is where much of the difficulty lies.


\section{A Formally Verified Implementation of the Factorial Function}
\label{\detokenize{05-putting-it-together:a-formally-verified-implementation-of-the-factorial-function}}
\begin{sphinxVerbatim}[commandchars=\\\{\}]

\end{sphinxVerbatim}

Here’s verified imperative program for computing factorial. We start
by documenting the overall program specification.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
method verified\PYGZus{}factorial(n: nat) returns (f: nat)
    ensures f == fact(n)
\end{sphinxVerbatim}

Now for the body of the method. First, if we’re looking at the case
where \sphinxstyleemphasis{n==0} we just return the right answer immediately. There is
no need for any further computation.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
if (n == 0)
\PYGZob{}
    return 1;
\PYGZcb{}
\end{sphinxVerbatim}

The rest of the code handles the case where \sphinxstyleemphasis{n \textgreater{} 1}. At this point in
the program execution, we believe that \sphinxstyleemphasis{n} must be greater than zero,
as we would have just returned if it were zero, and it can’t be
negative because its type is \sphinxstyleemphasis{nat}. We can nevertheless formally
assert (write a proposition about the state of the program) that \sphinxstyleemphasis{n}
is greater than zero. Dafny will try to (and here will successfully)
verify that the assertion is always true at this point in the program.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
assert n \PYGZgt{} 0;
\end{sphinxVerbatim}

Strategy: use a while loop to compute the answer. We can do this by
using a variable, a, to hold a “partial factorial value” in the form
of a product of the numbers from n down to a loop index, “i,” that we
start at n and decrement down, terminating the loop when \sphinxstyleemphasis{n==0}. At
each point just before, during, and right after the loop, \sphinxstyleemphasis{a} is a
product of the numbers from \sphinxstyleemphasis{n} down to \sphinxstyleemphasis{i}, and the value of \sphinxstyleemphasis{i}
represents how much of this product-computing work remains to be
done. So, for example, if we’re computing factorial(10) and a holds
the value \sphinxstyleemphasis{10 * 9}, then \sphinxstyleemphasis{i} must be \sphinxstyleemphasis{8} because the task of
multiplying \sphinxstyleemphasis{a} by the factors from \sphinxstyleemphasis{8} down to \sphinxstyleemphasis{1} remains to be
done. A critical “invariant” then is that if you multiply \sphinxstyleemphasis{a} by the
factorial of \sphinxstyleemphasis{i} you get the final answer, the factorial of \sphinxstyleemphasis{n}.
And in particular, when \sphinxstyleemphasis{i} gets down to \sphinxstyleemphasis{0}, \sphinxstyleemphasis{a} must contain the
final result, because \sphinxstyleemphasis{a * fact(0)} will then equal \sphinxstyleemphasis{fact(n)} and
\sphinxstyleemphasis{fact(0)} is just \sphinxstyleemphasis{1}, so \sphinxstyleemphasis{a} must equal \sphinxstyleemphasis{fact(n)}. This is how we
design loops so that we can be confident that they do what we want
tem to do.

Step 1. Set up state for the loop to work. We first initializie a := 1
and i := n and check that the invariant holds. Note that we are using
our pure functional math-like definition of fact as a \sphinxstyleemphasis{specification}
of the factorial function we’re implementing.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
var i: nat := n;    // nat type of i explicit
var a := 1;         // can let Dafny infer it
\end{sphinxVerbatim}

In Dafny, we can use matnematical logic to express what must be true
at any given point in the execution of a program in the form of an
“assertion.” Here we assert that our loop invariant holds. The Dafny
verifier tries to prove that the assertion is a true propsition about
the state of the program when control reaches this point in the
execution of this program.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
assert a * fact(i) == fact(n); // \PYGZdq{}invariant\PYGZdq{}
\end{sphinxVerbatim}

Step 2: Now evaluate the loop to get the answer. To evaluate a loop,
first, evaluate the loop condition (i \textgreater{} 0).Then , if the result is
false, terminate the loop. Otherwise, evaluate the loop body, then
iterate (run the loop again, starting by evaluating the loop
condition).

Note that we can deduce that the loop body is going to execute at
least once. It will run if i \textgreater{} 0. What is i? We initialized it to n
and haven’t change it since then so it must still be equal to n. Do we
know that n is greater than 0? We do, because (1) it can’t be negative
owning to its type, and (2) it can’t be 0 because if it were 0 the
program would already have returned. But we can now do better than
just reasoning in our heads; we can use logic to express what we
believe to be true and let Dafny try to check it for us automatically.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
assert i \PYGZgt{} 0;
\end{sphinxVerbatim}

Let’s just think briefly about cases. We know i can’t be zero. It
could be one. If it’s one, then the loop body will run. The loop body
will run. a, which starts at 1, will be multiplied by i, which is 1,
then i will be decremented.  It will have the value 0 and the loop
will not run again, leaving a with the value 1, which is the right
answer. So, okay, let’s run the loop.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
while (i \PYGZgt{}  0)
    invariant 0 \PYGZlt{}= i \PYGZlt{}= n
    invariant fact(n) == a * fact(i)
\PYGZob{}
    a := a * i;
    i := i \PYGZhy{} 1;
\PYGZcb{}
\end{sphinxVerbatim}

At this point, we know that the loop condition is false. In English,
we’d say it is no longer true that i is greater than zero.” We can do
better that saying this in natural language then forgetting it. We can
use formal logic to formalize and document our belief and if we do
this then Dafny pays us well for our effort by checking that our
assertion is true.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
assert !(i \PYGZgt{} 0);
\end{sphinxVerbatim}

We can also have Dafny check that our loop invariant still holds.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
assert a * fact(i) == fact(n);
\end{sphinxVerbatim}

And now comes the most crucial step of all in our reasoning. We can
deduce that a now holds the correct answer. That this is so follows
from the conjunction of the two assertions we just made. First, that i
is not greater than 0 and given that its type is nat, the only
possible value it can have now is 0. And that’s what we’d expect,
because that’s the condition on which the loop terminates, which is
just did! But better than just saying it, let us also formalize,
document, and check it.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
assert i == 0;
\end{sphinxVerbatim}

Now it’s easy to see. No matter what value i has, a * fact(i) ==
fact(n), and i == 0, so we have a * fact(0) == fact(n), and we know
that fact(0) is 1 because we see that in the very mathematical
definition of fact, so it must be that a = fact(n). Dafny can check!

\begin{sphinxVerbatim}[commandchars=\\\{\}]
assert a == fact(n);
\end{sphinxVerbatim}

We thus have the answer we need to return.  Dafny verifies that our
program satisfies its formal specification. We no longer have to
pray. We \sphinxstyleemphasis{know} that our program is right and Dafny confirms our
belief.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
return a;
\end{sphinxVerbatim}

Mathematical logic is to software as the calculus is to physics and
engineering.  It’s not just an academic curiosity. It is a critical
intellectual tool, inceasingly used for precise specification and
semi-automated reasoning about and verification of real programs.


\section{Case Study: Verified Implementation of the Fibonacci Function}
\label{\detokenize{05-putting-it-together:case-study-verified-implementation-of-the-fibonacci-function}}
Similarly, here an imperative implementation of the fibonacci
function, without a spec.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
method fibonacci(n: nat) returns (r: nat)
    ensures r == fib(n)
\end{sphinxVerbatim}

Now for the body. First we represent values for the two
cases where the result requires no further computation.
Initially, \sphinxstyleemphasis{fib0} will store the value of \sphinxstyleemphasis{fib(0)} and
\sphinxstyleemphasis{fib1} will store the value of \sphinxstyleemphasis{fib(1)}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
var fib0, fib1 := 0, 1; //parallel assmt
\end{sphinxVerbatim}

Next, we test to see if either of these cases applies,
and if so we just return the appropriate result.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
if (n == 0) \PYGZob{} return fib0; \PYGZcb{}
if (n == 1) \PYGZob{} return fib1; \PYGZcb{}
\end{sphinxVerbatim}

At this point, we know something more about the state of the program
than was the case when we started. We can deduce, which is to say that
we know, that \sphinxstyleemphasis{n} has to be greater than or equal to \sphinxstyleemphasis{2}. This is
because it initially had to be greater than or equal to zero due to
its type, and then we would already have returned if it were \sphinxstyleemphasis{0} or
\sphinxstyleemphasis{1}, to it must now be \sphinxstyleemphasis{2} or greater. We can document the belief
that the current state of the program has to property that the value
of the variable \sphinxstyleemphasis{n} is greater than or equal to \sphinxstyleemphasis{2}, and Dafny will
verify this assertion for us.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
assert n \PYGZgt{}= 2;
\end{sphinxVerbatim}

So now we have to deal with the case where \sphinxstyleemphasis{n \textgreater{}= 2}. Our strategy for
computing fib(n) in this case is to use a while loop with an index i.
Our design will be based on the idea that at the beginning and end of
each loop iteration (we are currently at the beginning), we will have
computed fib(i) and that its value is stored in fib1. We’ve already
assigned the value of fib(0) to fib0, and of fib(1) to fib1, so to set
up the desired state of affairs, we should initialize \sphinxstyleemphasis{i} to be \sphinxstyleemphasis{1}.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
var i := 1;
\end{sphinxVerbatim}

We can state and Dafny can verify a number of conditions that we
expect and require to hold at this point. First, \sphinxstyleemphasis{fib1} equals
\sphinxstyleemphasis{fib(i)}. Now to compute the next (\sphinxstyleemphasis{i+1}) Fibonacci number, we need
not only the value of \$fib(i)* but also \sphinxstyleemphasis{fib(i-1)}. We will thus also
want \sphinxstyleemphasis{fib0} to hold this value at the start and end of each loop
iteration, and indeed we do have that state of affairs right now.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
assert fib1 == fib(i);
assert fib0 == fib(i\PYGZhy{}1);
\end{sphinxVerbatim}

To compute \sphinxstyleemphasis{fib(n)} for any \sphinxstyleemphasis{n} greater than or equal to \sphinxstyleemphasis{2} will
require at least one execution of the loop body. We’ll thus set our
loop condition to be \$i \textless{} n\$. This ensures that the loop body will
run, as \sphinxstyleemphasis{i} is \sphinxstyleemphasis{1} and \sphinxstyleemphasis{n} is at least \sphinxstyleemphasis{2}, so the condition \sphinxstyleemphasis{i \textless{} n}
is \sphinxstyleemphasis{true}, which dictates that the loop body must be evaluated.

Within the loop body we’ll compute fib(i+1) (we call it \sphinxstyleemphasis{fib2} within
the loop) by adding together \sphinxstyleemphasis{fib0} and \sphinxstyleemphasis{fib1}; then we increment i;
then we update \sphinxstyleemphasis{fib0} and \sphinxstyleemphasis{fib1} so that for the \sphinxstyleemphasis{new} value of \sphinxstyleemphasis{i}
they hold \sphinxstyleemphasis{fib(i-1)} and \sphinxstyleemphasis{fib(i)}. To do this we assign the initial
value of \sphinxstyleemphasis{fib1} to \sphinxstyleemphasis{fib0} and the value of \sphinxstyleemphasis{fib2} to \sphinxstyleemphasis{fib1}.

Let’s work an example. Suppose \sphinxstyleemphasis{n} happens to be \sphinxstyleemphasis{2}. The loop body
will run, and after the one execution, \sphinxstyleemphasis{i} will have the value, \sphinxstyleemphasis{2};
\sphinxstyleemphasis{fib1} will have the value of \$fib(2)\$, and \sphinxstyleemphasis{fib0} will have the value
of \sphinxstyleemphasis{fib(1)\$. Because *i} is now \sphinxstyleemphasis{2} and \sphinxstyleemphasis{n} is still \sphinxstyleemphasis{2}, the loop
condition will now be false and the loop will terminate. The value of
\sphinxstyleemphasis{fib1} will of course be \sphinxstyleemphasis{fib(i)} but now we’ll also have that \sphinxstyleemphasis{i ==
n} (it takes a little reasoning to prove this), so \sphinxstyleemphasis{fib(i)} will be
\sphinxstyleemphasis{fib(n)}, which is the result we want and that we return.

We can also informally prove to ourself that this strategy gives us
a program that always terminates and returns a value. That is, it does
not go into an infinite loop. To see this, note that the value of \sphinxstyleemphasis{i}
is initally less than or equal to \sphinxstyleemphasis{n}, and it increases by only \sphinxstyleemphasis{1} on
each time through the loop. The value of \sphinxstyleemphasis{n} is finite, so the value
of \sphinxstyleemphasis{i} will eventually equal the value of \sphinxstyleemphasis{n} at which point the loop
condition will be falsified and the looping will end.

That’s our strategy. So let’s go. Here’s the while loop that we have
designed. And here, for the first time, we see something crucial. We
tell Dafny about certain properties of the state of the program that
hold both before and after every execution of the loop body. We call
such properties \sphinxstyleemphasis{invariants}. Dafny needs to know these invariants to
prove to itself (and to us) that the loop does what it is intended to
do: that the result at the end will be as desired.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
while (i \PYGZlt{} n)
    invariant i \PYGZlt{}= n;
    invariant fib0 == fib(i\PYGZhy{}1);
    invariant fib1 == fib(i);
\PYGZob{}
    var fib2 := fib0 + fib1;
    fib0 := fib1;
    fib1 := fib2;
    i := i + 1;
\PYGZcb{}
\end{sphinxVerbatim}

The invariants are just the conditions that we required to hold for
our design of the loop to work. First, \sphinxstyleemphasis{i} must never exceed \sphinxstyleemphasis{n}. If
it did, the loop would spin off into infinity. Second, to compute the
next (the \sphinxstyleemphasis{i+1st)} Fibonacci number we have to have the previous \sphinxstyleemphasis{two}
in memory. So \sphinxstyleemphasis{fib0} better hold \sphinxstyleemphasis{fib(i-1)} and \sphinxstyleemphasis{fib1}, \sphinxstyleemphasis{fib(i)}. Note
that these conditions do not have to hold \sphinxstyleemphasis{within} the execution of
the loop body, but they do have to hold before before and after each
execution.

The body of the loop is just as we described it above, and we can use
our own minds to deduce that if the invariants hold before the loop
body runs (and they do), then they will also hold after it runs. We
can also see that after the loop terminates, it must be that \sphinxstyleemphasis{i==n}.
This is because we know that it’s always true that \sphinxstyleemphasis{i \textless{}= n} and the
loop condition must now be false, which is to say that \sphinxstyleemphasis{i} can no
longer be strictly less than \sphinxstyleemphasis{n}, so \sphinxstyleemphasis{i} must now equal \sphinxstyleemphasis{n}. Logic
says so, and logic is right. What is amazing is that we can write
these assertions in Dafny if we wish to, and Dafny will verify that
they are true statements about the state of the program after the
loop has run. We have \sphinxstyleemphasis{proved} (or rather Dafny has proved and we
have recapitulated the proof in this sequence of assertions) that
we have without a doubt computed the right answer. Dafny has also
proved to itself that the loop always terminates, and so we have
in effect a formal proof of total correctness for this program.

\begin{sphinxVerbatim}[commandchars=\\\{\}]
assert i \PYGZlt{}= n;      // invariant
assert !(i \PYGZlt{} n);    // loop condition is false
assert (i \PYGZlt{}= n) \PYGZam{}\PYGZam{} !(i \PYGZlt{} n) ==\PYGZgt{} (i == n);
assert i == n;      // deductive conclusion
assert fib1 == fib(i); // invariant
assert fib1 == fib(i) \PYGZam{}\PYGZam{} (i==n) ==\PYGZgt{} fib1 == fib(n);
assert fib1 == fib(n);
return fib1;
\end{sphinxVerbatim}


\section{What is Dafny?}
\label{\detokenize{05-putting-it-together:what-is-dafny}}
Dafny is a cutting-edge software language and tooset developed at
Microsoft Research—one of the top computer science research labs in
the world—that provides such a capability. We will explore Dafny and
the ideas underlying it in the first part of this course, both to give
a sense of the current state of the art in program verification and,
most importantly, to explain why it’s vital for a computer scientist
today to have a substantial understanding of logic and proofs along
with the ability to \sphinxstyleemphasis{code}.

Tools such as TLA+, Dafny, and others of this variety give us a way
both to express formal specifications and imperative code in a unified
way (albeit in different sub-languages), and to have some automated
checking done in an \sphinxstyleemphasis{attempt} to verify that code satisfies its spec.

We say \sphinxstyleemphasis{attempt} here, because in general verifying the consistency of
code and a specification is a literally unsolvable problem. In cases
that arise in practice, much can often be done. It’s not always easy,
but if one requires ultra-high assurance of the consistency of code
and specification, then there is no choice but to employ the kinds of
\sphinxstyleemphasis{formal methods} introduced here.

To understand how to use such state-of-the-art software development
tools and methods, one must understand not only the language of code,
but also the languages of mathematical logic, including set and type
theory. One must also understand precisely what it means to \sphinxstyleemphasis{prove}
that a program satisfies its specification; for generating proofs is
exactly what tools like Dafny do \sphinxstyleemphasis{under the hood}.

A well educated computer scientist and a professionally trained
software developer must understand logic and proofs as well as coding,
and how they work together to help build \sphinxstyleemphasis{trustworthy} systems. Herein
lies the deep relevance of logic and proofs, which might otherwise
seem like little more than abstract nonsense and a distraction from
the task of learning how to program.


\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}



\renewcommand{\indexname}{Index}
\printindex
\end{document}